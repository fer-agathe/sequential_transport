# Gaussian Simulations {#sec-gaussian}

::: callout-note

## Objectives

This chapter demonstrates the sequential transport methodology applied to simulated bivariate Gaussian distributions. The sensitive attribute $S \in \left\{0,1\right\}$ is a binary variable, with each group $S=0$ and $S=1$, corresponding to a distinct bivariate Gaussian distribution. The objective is to transport $\boldsymbol{X} = (X_1,X_2)$ from group $S=0$ to group $S=1$ and analyze the effects on predictions $\hat{Y}$ obtained from a binary classifier. Here, the binary response variable $Y$ is simulated using a logistic regression model based on the covariates $(S,\boldsymbol{X})$.

:::

```{r setup, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: Display the setting codes

# Required packages----
library(tidyverse)
library(glue)
library(igraph)
library("wesanderson")
library(scales)
library(kableExtra)
library(expm)
library(ks)

# Graphs----
colours <- c(
  `0` = "#5BBCD6", 
  `1` = "#FF0000", 
  A = "#00A08A", 
  B = "#F2AD00", 
  with = "#046C9A", 
  without = "#C93312", 
  `2` = "#0B775E"
)

# Seed
set.seed(123)

source("functions/utils.R")
source("functions/graphs.R")
```

## Data

We start by drawing two bivariate Gaussian distributions, each reflecting one group from the sensitive attribute $S \in \left\{0,1\right\}$. Let us draw 100 observation per group. For group 0, we draw values from a multivariate Gaussian distribution with mean -1 and the following variance-covariance matrix: $\Sigma_0 = \begin{bmatrix}1.2^2 & \frac{1.2^2}{2}\\ \frac{1.2^2}{2} & 1.2^2\end{bmatrix}$.
For group 1, we draw values from a multivariate Gaussian distribution with mean 1.5 and with the following variance-covariance matrix: $\Sigma_0 = \begin{bmatrix}.9^2 & -\frac{4\times .9^2}{10}\\ -\frac{4 \times .9^2}{2} & .9^2\end{bmatrix}$.

```{r data-gaussian, message=FALSE, warning=FALSE}

# Number of observations per group
n <- 100

# First bivariate Gaussian distribution: group S=0
M0 <- c(-1,-1)
S0 <- matrix(c(1,.5,.5,1)*1.2^2,2,2)
X0 <- mnormt::rmnorm(n, M0, S0)
D_SXY_0 <- data.frame(
  S = 0,
  X1 = X0[, 1],
  X2 = X0[, 2]
)

# Second bivariate Gaussian distribution: group S=1
M1 <- c(1.5,1.5)
S1 <- matrix(c(1,-.4,-.4,1)*.9^2,2,2)
X1 <- mnormt::rmnorm(n, M1, S1)
D_SXY_1 <- data.frame(
  S = 1,
  X1 = X1[, 1],
  X2 = X1[, 2]
)
```

Then, we simulate a binary response variable with a logistic model depending of covariates $(S,\boldsymbol{X})$.

```{r logistic-model, message=FALSE, warning=FALSE}
# Drawing random binary response variable Y with logistic model for each group
eta_0 <- (D_SXY_0$X1 * 1.2 + D_SXY_0$X2 / 2 * .8) / 2
eta_1 <- (D_SXY_1$X1 * .8 + D_SXY_1$X2 / 2 * 1.2) / 2
p_0 <- exp(eta_0) / (1 + exp(eta_0))
p_1 <- exp(eta_1) / (1 + exp(eta_1))
D_SXY_0$Y <- rbinom(n, size = 1, prob = p_0)
D_SXY_1$Y <- rbinom(n, size = 1, prob = p_1)

# Final dataset
D_SXY <- rbind(D_SXY_0, D_SXY_1)
```

The contour lines of both bivariate Gaussian densities (corresponding to groups $S=0$ and $S=1$) are displayed in the following graph.

```{r density-gaussian, fig.height = 4, fig.width = 4, fig.align = "center", dev.args = list(bg = 'transparent'), message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: Display the codes used to create the Figure
#| fig-cap: Bivariate Gaussian densities within each group ($S=0$ on the left and $S=1$ on the right), estimated with a Gaussian kernel
D_SXY0 <- D_SXY[D_SXY$S == 0, ]
D_SXY1 <- D_SXY[D_SXY$S == 1, ]

# Computation of smoothing parameters (bandwidth) for kernel density estimation
H0 <- Hpi(D_SXY0[,c("X1","X2")])
H1 <- Hpi(D_SXY1[,c("X1","X2")])

# Calculating multivariate densities in each group S=0 and S=1
f0_2d <- kde(D_SXY0[,c("X1","X2")], H = H0, xmin = c(-5, -5), xmax = c(5, 5))
f1_2d <- kde(D_SXY1[,c("X1","X2")], H = H1, xmin = c(-5, -5), xmax = c(5, 5))

# Plotting densities
par(mar = c(2,2,0,0))
# Group S=0
contour(
  f0_2d$eval.point[[1]], f0_2d$eval.point[[2]], f0_2d$estimate, 
  col = colors["A"], axes = FALSE, xlab = "", ylab = ""
)
axis(1)
axis(2)
# Group S=1
contour(
  f1_2d$eval.point[[1]], f1_2d$eval.point[[2]], f1_2d$estimate, 
  col = colors["B"], add = TRUE)
# Display one individual on the graph in group S=0
points(-2, -1, pch = 19)
```

## Sequential Transport {#sec-gaussian-transport-functions}

In this part, we apply the sequential transport methodology by using transport functions. Note that they are also defined in the file `functions/utils.R`{.R}.


Let us define a function to to transport $X_1=x_1$ from group $S=0$ to $X_1=x_1^*$ from group $S=1$ i.e., $T_1^*(x_1)$. 

```{r define-transport_x1}
#' Transport of x1 from s=0 to s=1
#' 
#' @param x2 vector of x2's values
#' @descriptions
#'  - vx1_0_mid: coordinates of center of cells (axis x1, s=0)
#'  - f1_0: c.d.f. values for x1 in group s=0
#'  - u: quantile levels
#'  - q1_1: quantile values for x1 in group s=1
transport_x1 <- function(x1) {
  # identify closest cell of the grid to the coordinates of x1 in group s=0
  i <- which.min(abs(vx1_0_mid - x1))
  # c.d.f. for that cell, in group s=0
  p <- f1_0[i]
  # identify closest quantile level
  i <- which.min(abs(u - p))
  # corresponding quantile in group s=1
  x1star <- q1_1[i]
  x1star
}
```

Another function to transport $X_2=x_2$ from group $S=0$ to $X_2=x_2^*$ from group $S=1$, i.e., $T_2^*(x_2)$:
```{r define-transport_x2}
#' Transport of x2 from s=0 to s=1
#' 
#' @param x2 vector of x2's values
#' @descriptions
#'  - vx2_0_mid: coordinates of center of cells (axis x2, s=0)
#'  - f2_0: c.d.f. values for x2 in group s=0
#'  - u: quantile levels
#'  - q2_1: quantile values of x2 in group s=1
transport_x2 <- function(x2) {
  # identify closest cell of the grid to the coordinates of x2 in group s=0
  i <- which.min(abs(vx2_0_mid - x2))
  # c.d.f. for that cell, in group s=0
  p <- f2_0[i]
  # identify closest quantile level
  i <- which.min(abs(u - p))
  # corresponding quantile in group s=1
  x2star <- q2_1[i]
  x2star
}
```


A function to transport $X_2=x_2|X_1=x_1$ from group $S=0$ to $X_2=x_2^*|X_1=x_1^*$ from group $S=1$,, i.e., $T_1^*(x_1 | x_2)$:

```{r define-transport_x1_cond_x2}
#' Transport for x1 conditional on x2, from s=0 to s=1
#' 
#' @param x1 numerical vector with x1's values
#' @param x2 numerical vector with x2's values
#' @description
#'  - vx2_0_mid: coordinates of center of cells (axis x2, s=0)
#'  - vx2_1_mid: coordinates of center of cells (axis x2, s=1)
#'  - vx1_0_mid: coordinates of center of cells (axis x1, s=0)
transport_x1_cond_x2 <- function(x1, x2) {
  # identify closest cell in s=0 for x2 coordinate
  k0 <- which.min(abs(vx2_0_mid - x2))
  # identify closest cell in s=1 for transported x2 coordinate
  k1 <- which.min(abs(vx2_1_mid - transport_x2(x2)))
  # identify closest cell in s=0 for x1 coordinate
  i_0 <- which.min(abs(vx1_0_mid - x1))
  # c.d.f. for the closest cell in s=0 for x1 coordinates
  p <- F1_0[i_0, k0]
  # identify closest quantile level
  i_1 <- which.min(abs(u - p))
  # corresponding quantile in group s=1
  x1star <- Q1_1[i_1, k1]
  x1star
}
```

And a last function to transport $X_1=x_1|X_2=x_2$ from group $S=0$ to $X_1=x_1^*|X_2=x_2^*$ from group $S=1$, i.e., $T_2^*(x_2 |x_1)$:
```{r define-transport_x2_cond_x1}
#' Transport for x2 conditional on x1, from s=0 to s=1
#' 
#' @param x2 numerical vector with x2's values
#' @param x1 numerical vector with x1's values
#' @description
#'  - vx1_0_mid: coordinates of center of cells (axis x1, s=0)
#'  - vx1_1_mid: coordinates of center of cells (axis x1, s=1)
#'  - vx2_0_mid: coordinates of center of cells (axis x2, s=0)
transport_x2_cond_x1 <-  function(x2, x1){
  # identify closest cell in s=0 for x1 coordinate
  k0 <- which.min(abs(vx1_0_mid - x1))
  # identify closest cell in s=1 for transported x1 coordinate
  k1 <- which.min(abs(vx1_1_mid - transport_x1(x1)))
  # identify closest cell in s=0 for x2 coordinate
  i_0 <- which.min(abs(vx2_0_mid - x2))
  # c.d.f. for the closest cell in s=0 for x2 coordinates
  p <- F2_0[i_0, k0]
  # identify closest quantile level
  i_1 <- which.min(abs(u - p))
  # corresponding quantile in group s=1
  x2star <-  Q2_1[i_1, k1]
  x2star
}
```

## Algorithm: Sequential Conditional Transport

To obtain the counterfactuals based on the methodology presented in the article, i.e., on sequential transport using a causal graph, we can use @alg-1.

```pseudocode
#| label: alg-1
#| html-indent-size: "1.2em"
#| html-comment-delimiter: "//"
#| html-line-number: true
#| html-line-number-punc: ":"
#| html-no-end: false
#| pdf-placement: "htb!"
#| pdf-line-number: true

\begin{algorithm}
\caption{Sequential transport on causal graph}
\begin{algorithmic}
\Require graph \(\mathcal{G}\) on \((s,\boldsymbol{x})\), with adjacency matrix \(\boldsymbol{A}\)
\Require dataset \((s_i,\boldsymbol{x}_i)\) and one individual \((s=0,\boldsymbol{a})\)
\Require bandwidths \(\boldsymbol{h}\) and \(\boldsymbol{b}_j\)'s 
\State \((s,\boldsymbol{v})\gets\boldsymbol{A}\) the topological ordering of vertices (DFS)
\State \(T_s\gets\text{identity}\)
\For{\(j\in \boldsymbol{v}\)} 
    \State \(\boldsymbol{p}(j) \gets \text{parents}(j)\)
    \State \(T_j(\boldsymbol{a}_{\boldsymbol{p}(j)})\gets (T_{\boldsymbol{p}(j)_1}(\boldsymbol{a}_{\boldsymbol{p}(j)}),\cdots,T_{\boldsymbol{p}(j)_{k_j}}(\boldsymbol{a}_{\boldsymbol{p}(j)}))\)
    \State \((x_{i,j|s},\boldsymbol{x}_{i,\boldsymbol{p}(j)|s})\gets\) subsets when \(s\in\{0,1\}\)
    \State \(w_{i,j|0}\gets \phi(\boldsymbol{x}_{i,\boldsymbol{p}(j)|0};\boldsymbol{a}_{\boldsymbol{p}(j)},\boldsymbol{b}_j)\) (Gaussian kernel) 
    \State \(w_{i,j|1}\gets \phi(\boldsymbol{x}_{i,\boldsymbol{p}(j)|1};T_j(\boldsymbol{a}_{\boldsymbol{p}(j)}),\boldsymbol{b}_j)\) 
    \State \(\hat{f}_{h_j|s}\gets \text{density estimator}\) of \(x_{\cdot,j|s}\), weights \(w_{\cdot,j|s}\). 
    \State \(\hat{F}_{h_j|s}(\cdot)\gets\displaystyle\int^{~\cdot}_{-\infty}\hat{f}_{h_j|s}(u)\mathrm{d}u\), c.d.f.
    \State \(\hat{Q}_{h_j|s}\gets \hat{F}_{h_j|s}^{-1}\), quantile
    \State \(\hat{T}_{j}(\cdot)\gets\hat{Q}_{h_j|1}\circ \hat{F}_{h_j|0}(\cdot)\)
\EndFor
\State \(\boldsymbol{a}^\star\gets (T_{1}(\boldsymbol{a}_{1}),\cdots,T_{d}(\boldsymbol{a}_{d}))\)\\
\Return \((s=1,\boldsymbol{a}^\star)\), counterfactual of \((s=0,\boldsymbol{a})\) 
\end{algorithmic}
\end{algorithm}
```

While @alg-1 is intuitive, it becomes inefficient when computing counterfactuals for thousands of individuals, as conditional densities, c.d.f.'s and quantile functions should be computed for each individual. An alternative is to compute these quantities on a grid, store them, and then retrieve them as needed. These objects are generated using @alg-3 

In @alg-3 if $j$ has no parents, $\mathrm{parents}(j)=\varnothing$, $d_j=0$ and then $F_{j|s}$ and $Q_{j|s}$ are vectors (of length $k$). In @alg-4, in that case, $\boldsymbol{i}_0=\boldsymbol{i}_1=\varnothing$.

```pseudocode
#| label: alg-3
#| html-indent-size: "1.2em"
#| html-comment-delimiter: "//"
#| html-line-number: true
#| html-line-number-punc: ":"
#| html-no-end: false
#| pdf-placement: "htb!"
#| pdf-line-number: true
\begin{algorithm}
\caption{Faster sequential transport on causal graph (1)}
\begin{algorithmic}
\Require graph on \((s,\boldsymbol{x})\), with adjacency matrix \(\boldsymbol{A}\)
\Require dataset \((s_i,\boldsymbol{x}_i)\) and \(k\in\mathbb{N}\) some grid size,
\Require grids \(\boldsymbol{g}_{j|s}=({g}_{j,1|s},\cdots,{g}_{j,k|s})\), for all variable \(j\) \Require grid \(\boldsymbol{u}=(1,\cdots,k)/(k+1)\), for all \(j\) 
\State \((s,\boldsymbol{v})\gets\boldsymbol{A}\) the topological ordering of vertices (DFS)
\For{\(j\in \boldsymbol{v}\)} 
    \State \(\boldsymbol{p}(j) \gets \text{parents}(j)\), dimension \(d_j\)
    \State \(\mathcal{G}_{j|s}\gets\) grid \(\boldsymbol{g}_{\boldsymbol{p}(j)_1|s}\times\cdots\times\boldsymbol{g}_{\boldsymbol{p}(j)_{d_j}|s}\)
    \State \(F_{j|s}\gets\) tensors \(k\times k^{d_j}\), taking values in \(\boldsymbol{u}\)
    \State \(Q_{j|s}\gets\) tensors \(k\times k^{d_j}\), taking values in \(\boldsymbol{g}_{j|s}\)
    \For{\(\boldsymbol{i}=(i_1,\cdots,i_{d_j})\in\{1,\cdots,k\}^{d_j}\)} 
    \State \(F_{j|s}[\cdot,\boldsymbol{i}]\gets\) c.d.f. of \(X_j|\boldsymbol{X}_{\boldsymbol{p}(j)}=\boldsymbol{g}_{\boldsymbol{i}|s},S=s\)
    \State \(Q_{j|s}[\cdot,\boldsymbol{i}]\gets\) quantile of \(X_j|\boldsymbol{X}_{\boldsymbol{p}(j)}=\boldsymbol{g}_{\boldsymbol{i}|s},S=s\)
\EndFor
\EndFor
\end{algorithmic}
\end{algorithm}
```

```pseudocode
#| label: alg-4
#| html-indent-size: "1.2em"
#| html-comment-delimiter: "//"
#| html-line-number: true
#| html-line-number-punc: ":"
#| html-no-end: false
#| pdf-placement: "htb!"
#| pdf-line-number: true

\begin{algorithm}
\caption{Counterfactual calculation on causal graph (2)}
\begin{algorithmic}
\Require \(F_{1|s},\cdots,F_{d|s}\) and \(Q_{d|s},\cdots,Q_{d|s}\)
\Require grids \(\boldsymbol{g}_{1|s},\cdots,\boldsymbol{g}_{d|s}\), \(\mathcal{G}_{1|s},\cdots,\mathcal{G}_{d|s}\) and \(\boldsymbol{u}\)
\Require features \(\boldsymbol{a}\in\mathbb{R}^d\) (group 0)
\State \(\boldsymbol{b}\gets \boldsymbol{a}\)
\For{\(j\in \boldsymbol{v}\)} 
  \State \(\boldsymbol{i}_0\gets \boldsymbol{a}_{\boldsymbol{p}(j)}\) on grid \(\mathcal{G}_{j|0}\) 
  \State \(k_0\gets a_j\) on grid \(\boldsymbol{g}_{j|0}\)
  \State \(p\gets F_{j|0}[k_0,\boldsymbol{i}_0]\)
  \State \(\boldsymbol{i}_1\gets \boldsymbol{b}_{\boldsymbol{p}(j)}\) on grid \(\mathcal{G}_{j|1}\) 
  \State \(k_1\gets p\) on grid \(\boldsymbol{u}\)
  \State \(b_j\gets Q_{j|1}[k_1,\boldsymbol{i}_1]\)
\EndFor
\Return \(\boldsymbol{b}\) (counterfactual in group 1)
\end{algorithmic}
\end{algorithm}
```


We define a function, `fonction_transport()`{.R}, which performs sequential transport, using the fast algorithm (a step by step example is presented in @sec-regression-algo-example.
```{r}
#' Sequential transport
#'
#' @param data dataset with three columns:
#'  - S: sensitive attribute
#'  - X1: first predictor, assumed to be causally linked to S
#'  - X2: second predictor, assumed to be causally linked to S and X1
#' @param S_0 value for the sensitive attribute for the source distribution
#' @param number of cells in each dimension (default to 15)
#' @param h small value added to extend the area covered by the grid (default
#'  to .2)
#' @param d neighborhood weight when conditioning by x1 (default to .5)
fonction_transport <- function(data,
                               S_0,
                               n_grid = 15,
                               h = .2,
                               d = .5
                               ) {

  # Subset of the data: 0 for Black, 1 for White
  D_SXY_0 <- data[data$S ==S_0, ]
  D_SXY_1 <- data[data$S!= S_0, ]

  # Coordinates of the cells of the grid on subset of 0 (Black)
  vx1_0 <- seq(min(D_SXY_0$X1) - h, max(D_SXY_0$X1) + h, length = n_grid + 1)
  vx2_0 <- seq(min(D_SXY_0$X2) - h, max(D_SXY_0$X2) + h, length = n_grid + 1)
  # and middle point of the cells
  vx1_0_mid <- (vx1_0[2:(1+n_grid)]+vx1_0[1:(n_grid)]) / 2
  vx2_0_mid <- (vx2_0[2:(1+n_grid)]+vx2_0[1:(n_grid)]) / 2

  # Coordinates of the cells of the grid on subset of 1 (White)
  vx1_1 <- seq(min(D_SXY_1$X1) -h, max(D_SXY_1$X1) + h, length = n_grid + 1)
  vx1_1_mid <- (vx1_1[2:(1 + n_grid)] + vx1_1[1:(n_grid)]) / 2
  # and middle point of the cells
  vx2_1 <- seq(min(D_SXY_1$X2) - h, max(D_SXY_1$X2) + h, length = n_grid + 1)
  vx2_1_mid <- (vx2_1[2:(1 + n_grid)] + vx2_1[1:(n_grid)]) / 2

  # Creation of the grids for the CDF and Quantile function
  # init with NA values
  # One grid for X1 and X2, on both subsets of the data (Black/White)
  F1_0 <- F2_0 <- F1_1 <- F2_1 <- matrix(NA, n_grid, n_grid)
  Q1_0 <- Q2_0 <- Q1_1 <- Q2_1 <- matrix(NA, n_grid, n_grid)

  # Empirical CDF for X1 on subset of Black
  FdR1_0 <- Vectorize(function(x) mean(D_SXY_0$X1 <= x))
  f1_0 <- FdR1_0(vx1_0_mid)
  # Empirical CDF for X2 on subset of Black
  FdR2_0 <- Vectorize(function(x) mean(D_SXY_0$X2 <= x))
  f2_0 <- FdR2_0(vx2_0_mid)
  # Empirical CDF for X1 on subset of White
  FdR1_1 <- Vectorize(function(x) mean(D_SXY_1$X1 <= x))
  f1_1 <- FdR1_1(vx1_1_mid)
  # Empirical CDF for X2 on subset of White
  FdR2_1 <- Vectorize(function(x) mean(D_SXY_1$X2 <= x))
  f2_1 <- FdR2_1(vx2_1_mid)

  u <- (1:n_grid) / (n_grid + 1)
  # Empirical quantiles for X1 on subset of Black
  Qtl1_0 <- Vectorize(function(x) quantile(D_SXY_0$X1, x))
  q1_0 <- Qtl1_0(u)
  # Empirical quantiles for X2 on subset of Black
  Qtl2_0 <- Vectorize(function(x) quantile(D_SXY_0$X2, x))
  q2_0 <- Qtl2_0(u)
  # Empirical quantiles for X1 on subset of White
  Qtl1_1 <- Vectorize(function(x) quantile(D_SXY_1$X1, x))
  q1_1 <- Qtl1_1(u)
  # Empirical quantiles for X2 on subset of White
  Qtl2_1 <- Vectorize(function(x) quantile(D_SXY_1$X2, x))
  q2_1 <- Qtl2_1(u)

  for(i in 1:n_grid) {
    # Subset of Black
    idx1_0 <- which(abs(D_SXY_0$X1 - vx1_0_mid[i]) < d)
    FdR2_0 <- Vectorize(function(x) mean(D_SXY_0$X2[idx1_0] <= x))
    F2_0[, i] <- FdR2_0(vx2_0_mid)
    Qtl2_0 <- Vectorize(function(x) quantile(D_SXY_0$X2[idx1_0], x))
    Q2_0[, i] <- Qtl2_0(u)

    idx2_0 <- which(abs(D_SXY_0$X2 - vx2_0_mid[i]) < d)
    FdR1_0 <- Vectorize(function(x) mean(D_SXY_0$X1[idx2_0] <= x))
    F1_0[, i] <- FdR1_0(vx1_0_mid)
    Qtl1_0 <- Vectorize(function(x) quantile(D_SXY_0$X1[idx2_0], x))
    Q1_0[, i] <- Qtl1_0(u)

    # Subset of White
    idx1_1 <- which(abs(D_SXY_1$X1 - vx1_1_mid[i]) < d)
    FdR2_1 <- Vectorize(function(x) mean(D_SXY_1$X2[idx1_1] <= x))
    F2_1[, i] <- FdR2_1(vx2_1_mid)
    Qtl2_1 <- Vectorize(function(x) quantile(D_SXY_1$X2[idx1_1], x))
    Q2_1[, i] <- Qtl2_1(u)

    idx2_1 <- which(abs(D_SXY_1$X2-vx2_1_mid[i])<d)
    FdR1_1 <- Vectorize(function(x) mean(D_SXY_1$X1[idx2_1] <= x))
    F1_1[, i] <- FdR1_1(vx1_1_mid)
    Qtl1_1 <- Vectorize(function(x) quantile(D_SXY_1$X1[idx2_1], x))
    Q1_1[, i] <- Qtl1_1(u)
  }

  # Transport for X2
  T2 <- function(x2) {
    i <- which.min(abs(vx2_0_mid - x2))
    p <- f2_0[i]
    i <- which.min(abs(u - p))
    x2star <- q2_1[i]
    x2star
  }

  # Transport for X1
  T1 <- function(x1) {
    i <- which.min(abs(vx1_0_mid - x1))
    p <- f1_0[i]
    i <- which.min(abs(u - p))
    x1star <- q1_1[i]
    x1star
  }

  # Transport for X2 conditional on X1
  T2_cond_x1 <- function(x2, x1) {
    k0 <- which.min(abs(vx1_0_mid - x1))
    k1 <- which.min(abs(vx1_1_mid - T1(x1)))
    i <- which.min(abs(vx2_0_mid - x2))
    p <- F2_0[i, k0]
    i <- which.min(abs(u - p))
    x2star <- Q2_1[i, k1]
    x2star
  }

  # Transport for X1 conditional on X2
  T1_cond_x2 <- function(x1, x2) {
    k0 <- which.min(abs(vx2_0_mid - x2))
    k1 <- which.min(abs(vx2_1_mid - x2))
    i <- which.min(abs(vx1_0_mid - x1))
    p <- F1_0[i, k0]
    i <- which.min(abs(u - p))
    x1star <- Q1_1[i, k1]
    x1star
  }

  list(
    Transport_x1 = T1,
    Transport_x2 = T2,
    Transport_x1_cond_x2 = T1_cond_x2,
    Transport_x2_cond_x1 = T2_cond_x1
  )
}
```



```{r seq-transport-functions, message=FALSE, warning=FALSE}
data <- D_SXY
# Transform S to apply fonction_transport from utils.R
data <- data |> mutate(S = ifelse(S == 0, "Black", "White"))

# Parameters for the sequential transport algorithm
data <- D_SXY
S_0 <- 0 # source distribution (S=1 is the target distribution)
n_grid <- 500 # Number of bins to split each covariate
h <- .2 # Range extension window for each covariate
d <- .5 # Neighbourhood for conditioning

# Defining transport functions
seq_functions <- fonction_transport(
  data = data, S_0 = S_0, 
  n_grid = n_grid, h = h, d = d
)
T_X1 <- seq_functions$Transport_x1
T_X2 <- seq_functions$Transport_x2
T_X2_c_X1 <- seq_functions$Transport_x2_cond_x1
T_X1_c_X2 <- seq_functions$Transport_x1_cond_x2

```

We start by applying function `T_X1`{.R} above to transport only on the variable $X_1$. We will depict the resulting mapping for all observations. The densities of $X_1$ given groups $S=0$ and $S=1$ are calculated.

```{r transport-x1-grid, echo=FALSE, message=FALSE, warning=FALSE}

# Calculation of transport line for different values of X1 (grid)
x1_grid_t <- seq(-3.5, 1.75, length = 251)
x1_star_grid_t <- Vectorize(T_X1)(x1_grid_t)

# Calculation of densities with grid values for X1 
x1_grid_d <- seq(-5, 5, length = 251)
# Density of X1 in subset 0
d0x1 <- function(x) density(D_SXY0[,"X1"], bw = .2,
                            from = x, to = x, n = 1)$y
density_x1_0 <- Vectorize(d0x1)(x1_grid_d)
d_0 <- data.frame(x = x1_grid_d, y = density_x1_0)
# Density of X1 in subset 1
d1x1 <- function(x) density(D_SXY1[,"X1"], bw = .2,
                            from = x, to = x, n = 1)$y
density_x1_1 <- Vectorize(d1x1)(x1_grid_d)
d_1 <- data.frame(x = x1_grid_d, y = density_x1_1)

```

In the following graphs, the example of the transportation of one individual with $S=0$ will be displayed:

```{r transport-example-indiv, message=FALSE, warning=FALSE}

# Individual from subset S=0 to transport
x1 <- -2
x2 <- -1
x1_star <- T_X1(x1)
x2_c_x1_star = T_X2_c_X1(x2, x1)

```

We also calculate the indices of $X_1$ and $X_2$ grids that are below this individual ($x_1$ and $x_2$) and its counterfactual ($x_1^*$ and $x_2^*$) in order to plot the cdf's of $X_1$ and $X_2|X_1$ in both subsets $S=0$ and $S=1$ in the following graphs:

```{r indices-example-x1, message=FALSE, warning=FALSE}

# Define indices of X1 grid 
idx1 <- which(d_0$x <= x1)
idx1_star <- which(d_0$x <= x1_star)

# Define indices of X2|X1 grid 
idx2 <- which(d_0$x <= x2)
idx2_star <- which(d_0$x <= x2_c_x1_star)

```

Here, we plot the optimal transport curve for $X_1$ from subset $S=0$ to subset $S=1$ with the densities corresponding to each subset. Additionnally, the result for the individual from above is displayed.

```{r plot-transport-x1, fig.height = 4, fig.width = 4, fig.align = "center", dev.args = list(bg = 'transparent'), message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: Display the codes used to create the Figure

# Graph parameters
par(mar = c(2,2,0,0))
limA <- c(-5, 5)
limB <- c(-5, 5) 
limY <- c(0, .5)
lab <- c("A", "B")
sub <- 6
{
  mat <- matrix(c(1, 2, 0, 3), 2)
  par(mfrow = c(2, 2))
  layout(mat, c(3.5, 1), c(1, 3))
  par(mar = c(0.5, 4.5, 0.5, 0.5))
}

# Plot density of X1 in subset S=0
plot(d_0$x, d_0$y, type = "l", col = COLORS[lab[1]], lwd = 2,
     axes = FALSE, xlab = "", ylab = "", xlim = limA, ylim = limY)
polygon(c(min(d_0$x), d_0$x, max(d_0$x)), c(0, d_0$y, 0), 
        col = scales::alpha(COLORS[lab[1]], 0.1), border = NA)
# Plot cdf of X1 in subset S=0
polygon(c(min(d_0$x), d_0$x[idx1], max(d_0$x[idx1])),
        c(0,d_0$y[idx1],0),
        col = scales::alpha(colors["A"],.2),
        border = NA)
# Add x-axis for density and cdf
axis(1, at = seq(limA[1], limA[2], length = sub), 
     label = c(NA, seq(limA[1], limA[2], length = sub)[-1]))

# Plot transport line on X1 from S=0 to S=1
par(mar = c(4.5, 4.5, 0.5, 0.5))
u_grid <- seq(0, 1, length=261)
u_grid <- u_grid[2:260]
plot(x1_grid_t, x1_star_grid_t, col = COLORS["1"], lwd = 2, 
     type = "l", xlab = "", ylab = "", xlim = limA, ylim = limB, 
     axes = FALSE)
# Identity function line
abline(a = 0, b = 1, col = COLORS["0"], lty = 2)

# Add x-axis and y-axis of the transport line
axis(1)
axis(2)
# Legend
mtext("distribution (group 0)", side = 1, line = 3, col = "black")
mtext("distribution (group 1)", side = 2, line = 3, col = "black")

# Plot individual from subset S=0
points(x1, x1_star, pch = 19, col = COLORS["1"])
segments(x1, x1_star, x1, 10, lwd = .4, col = COLORS["1"])
segments(x1, x1_star, 10, x1_star, lwd = .4, col = COLORS["1"])

# Plot density of X1 in subset S=1
par(mar = c(4.5, 0.5, 0.5, 0.5))
plot(d_1$y, d_1$x, type = "l", col = COLORS[lab[2]], lwd = 2, 
     ylim = limB, xlim = limY, xlab = "", ylab = "", axes = FALSE)
polygon(c(0, d_1$y, 0), c(min(d_1$x), d_1$x, max(d_1$x)), 
        col = scales::alpha(COLORS[lab[2]], 0.1), border = NA)
# Plot cdf of X1 in subset S=1
polygon(c(0, d_1$y[idx1_star], 0),
        c(min(d_1$x), d_1$x[idx1_star], max(d_1$x[idx1_star])),
        col = scales::alpha(colors["B"],.2),
        border = NA)
# Add y-axis for density and cdf
axis(2, at = seq(limB[1], limB[2], length = sub), 
     label = c(NA, seq(limB[1], limB[2], length = sub)[-c(1, sub)], NA))

```
Then we plot the counterfactual obtained from sequential transport on $X_1$ (which corresponds to univariate optimal transport) for the individual, on the contour lines of both groups $S=0$ and $S=1$.

```{r transport-x1-contour-lines, fig.height = 4, fig.width = 4, fig.align = "center", dev.args = list(bg = 'transparent'), message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: Display the codes used to create the Figure

# Graph parameters
par(mar = c(2,2,0,0))

# Contour line of bivariate Gaussian density for subset S=0
contour(f0_2d$eval.point[[1]], f0_2d$eval.point[[2]],
        f0_2d$estimate, col = scales::alpha(colors["A"],.4),
        axes = FALSE, xlab = "", ylab = "")
# Contour line of bivariate Gaussian density for subset S=1
contour(f1_2d$eval.point[[1]], f1_2d$eval.point[[2]],
        f1_2d$estimate, col = scales::alpha(colors["B"],.4), 
        add = TRUE)

# Add x-axis and y-axis
axis(1)
axis(2)

# Plot density of X1 for subset S=0
polygon(c(min(d_0$x), d_0$x, max(d_0$x)), 
        c(0, d_0$y, 0)*5-5, 
        col = scales::alpha(COLORS[lab[1]], 0.4), 
        border = NA)
# Add cdf of X1 for subset S=0
polygon(c(min(d_0$x), d_0$x[idx1], max(d_0$x[idx1])),
        c(0, d_0$y[idx1],0)*5-5,
        col = scales::alpha(colors["A"], 0.4),
        border = NA)

# Plot density of X1 for subset S=1
polygon(c(min(d_1$x), d_1$x, max(d_1$x)),
        c(0, d_1$y, 0)*5-5, 
        col = scales::alpha(COLORS[lab[2]], 0.4), border = NA)
# Add cdf of X1 for subset S=1
polygon(c(min(d_1$x), d_1$x[idx1_star], max(d_1$x[idx1_star])),
        c(0, d_1$y[idx1_star],0)*5-5,
        col = scales::alpha(colors["B"],.4),
        border = NA)

# Plot example individual from subset S=0
points(x1, x2, pch = 19)
abline(v = x1, lwd = .4, col = COLORS["A"])
abline(v = x1_star, col = "black", lwd = .5)

```
Next, we plot the optimal transport curve for $X_2|X_1$ from subset $S=0$ to subset $S=1$ with the densities corresponding to each subset. Additionnally, the result for the individual from above is displayed. We use the same graph parameters than above.

We start by computing sequential transport for the example individual from subset $S=0$ (find the transport of $X_2=x_2|X_1=x_1$). For this, we need to compute different weights, defined with a Gaussian kernel, to calculate density of $X_2$ conditioned on the value $X_1=x_1$ (resp. $X_1=x_1^*$) for subset $S=0$ (resp. $S=1$).

```{r gaussian-kernel-x2-c-x1, message=FALSE, warning=FALSE}

# Calculation of transport line for X2|X1 on a grid for X2
x2_grid_t <- seq(-4.5, 2, length=251)
x2_star_grid_t <- Vectorize(function(x) T_X2_c_X1(x, x1))(x2_grid_t)

# Standard deviation for gaussian kernel (bandwidth)
h = .25

# Subset S=0
w0 <-  dnorm(D_SXY0[,"X1"], x1, h)
w0 <- w0/sum(w0)
d0x2cx1 <- function(x) density(D_SXY0[,"X2"],
                               bw = .3,
                               weights = w0,
                               from = x, to = x, n = 1)$y
# We use the same grid for X1 and X2 because they are both defined on the same range
density_x2cx1_0 <- Vectorize(d0x2cx1)(d_0$x)

# Subset S=1
w1 <- dnorm(D_SXY0[,"X1"], x1_star, h)
w1 <- w1/sum(w1)
d1x2cx1 <- function(x) density(D_SXY1[,"X2"],
                            bw = .3, 
                            weights = w1, 
                            from = x, to = x, n = 1)$y
density_x2cx1_1 <- Vectorize(d1x2cx1)(d_1$x)

```

Here, we plot the optimal transport curve for $X_2|X_1$ from subset $S=0$ to subset $S=1$ with the densities corresponding to each subset (calculated with Gaussian kernels). Additionnally, the result for the individual from above is displayed.

```{r plot-transport-x2-c-x1, fig.height = 4, fig.width = 4, fig.align = "center", dev.args = list(bg = 'transparent'), message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: Display the codes used to create the Figure

# Graph parameters
{
  mat <- matrix(c(1, 2, 0, 3), 2)
  par(mfrow = c(2, 2))
  layout(mat, c(3.5, 1), c(1, 3))
  par(mar = c(0.5, 4.5, 0.5, 0.5))
}

# Plot density of X2|X1 in subset S=0 with weights w0
plot(d_0$x, density_x2cx1_0, type = "l", col = COLORS[lab[1]], lwd = 2,
     axes = FALSE, xlab = "", ylab = "", xlim = limA, ylim = limY)
polygon(c(min(d_0$x), d_0$x, max(d_0$x)), c(0, density_x2cx1_0, 0), 
        col = scales::alpha(COLORS[lab[1]], 0.1), border = NA)
# Plot cdf of X1 in subset S=0 with weights w0
polygon(c(min(d_0$x), d_0$x[idx2], max(d_0$x[idx2])), c(0, density_x2cx1_0[idx2], 0),
        col = scales::alpha(colors["A"],.2),
        border = NA)
# Add x-axis for cdf and density
axis(1, at = seq(limA[1], limA[2], length = sub), 
     label = c(NA, seq(limA[1], limA[2], length = sub)[-1]))

# Plot transport line for X2|X1 from subset S=0 to S=1
par(mar = c(4.5, 4.5, 0.5, 0.5))
plot(x2_grid_t, x2_star_grid_t, col = COLORS["1"], lwd = 2,
     type = "l", xlab = "", ylab = "", xlim = limA, ylim = limB,
     axes = FALSE)
abline(a = 0, b = 1, col = COLORS["0"], lty = 2)

# Add x-axis and y-axis
axis(1)
axis(2)

# Legend
mtext("distribution (group 0)", side = 1, line = 3, col = "black")
mtext("distribution (group 1)", side = 2, line = 3, col = "black")

# Plot example individual on the transport line
points(x2, x2_c_x1_star, pch = 19, col = COLORS["1"])
segments(x2, x2_c_x1_star, x2, 10, lwd = .4, col = COLORS["1"])
segments(x2, x2_c_x1_star, 10, x2_c_x1_star, lwd = .4, col = COLORS["1"])

# Plot density of X2|X1 in subset S=1 with weights w1
par(mar = c(4.5, 0.5, 0.5, 0.5))
plot(density_x2cx1_1, d_1$x, type = "l", col = COLORS[lab[2]], lwd = 2,
     axes = FALSE, xlab = "", ylab = "", xlim = limY, ylim = limB)
polygon(c(0, density_x2cx1_1, 0), c(min(d_1$x), d_1$x, max(d_1$x)),
        col = scales::alpha(COLORS[lab[2]], 0.1), 
        border = NA)
# Plot cdf of X1 in subset S=1 with weights w1
polygon(c(0, density_x2cx1_1[idx2_star], 0), 
        c(min(d_1$x), d_1$x[idx2_star], max(d_1$x[idx2_star])),
        col = scales::alpha(colors["B"], .2),
        border = NA)
# Add y-axis for cdf and density
axis(2, at = seq(limB[1], limB[2], length = sub), label = c(NA, 
        seq(limB[1], limB[2], length = sub)[-c(1, sub)], NA))

```
Then we plot the counterfactual obtained from sequential transport on $X_2|X_1$ (which corresponds to univariate conditional transport) for the individual, on the contour lines of both groups $S=0$ and $S=1$.

```{r transport-x2-c-x1-contour-lines, fig.height = 4, fig.width = 4, fig.align = "center", dev.args = list(bg = 'transparent'), message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: Display the codes used to create the Figure

# Graph parameters
par(mar = c(2, 2, 0, 0))

# Contour lines for bivariate density of gaussian distribution in subset S=0
contour(f0_2d$eval.point[[1]], f0_2d$eval.point[[2]],
        f0_2d$estimate, col = scales::alpha(colors["A"],.4),
        axes = FALSE, xlab = "", ylab = "")

# x-axis and y-axis
axis(1)
axis(2)

# Contour lines for bivariate density of gaussian distribution in subset S=1
contour(f1_2d$eval.point[[1]], f1_2d$eval.point[[2]],
        f1_2d$estimate, col = scales::alpha(colors["B"],.4), add=TRUE)

# Plot the density of X2|X1 in subset S=0 with weights w0
polygon(c(0, density_x2cx1_0, 0)*5-2, c(-5, d_0$x, 5), 
        col = scales::alpha(COLORS[lab[1]], 0.4), 
        border = NA)
# Plot the cdf of X2|X1 in subset S=0
polygon(c(0, density_x2cx1_0[idx2], 0)*5-2,
        c(min(d_0$x), d_0$x[idx2], max(d_0$x[idx2])),
        col = scales::alpha(colors["A"],.4),
        border = NA)
# Plot crossing lines (X1, X2) at example individual from subset S=0
abline(v = x1, col = COLORS["A"], lwd = .5)
abline(h = x2, col = COLORS[lab[1]], lwd = .5)
points(x1, x2, pch=19)

# Plot the density of X2|X1 in subset S=1 with weights w1
polygon(c(0, density_x2cx1_1, 0)*5+x1_star, c(-5, d_1$x, 5), 
        col = scales::alpha(COLORS[lab[2]], 0.4), 
        border = NA)
# Plot the cdf of X2|X1 in subset S=1
polygon(c(0, density_x2cx1_1[idx2_star], 0)*5+x1_star,
        c(min(d_1$x), d_1$x[idx2_star], max(d_1$x[idx2_star])),
        col = scales::alpha(colors["B"],.4),
        border = NA)
# Plot crossing lines (X1, X2) at example individual when transported to subset S=1
abline(v = x1_star, col = COLORS[lab[2]], lwd = .5)
abline(h = x2_c_x1_star, col = "black", lwd = .5)
points(x1_star, x2_c_x1_star, pch=19)

```
## Faster Sequential Transport

In this part, we establish grids for $X_1$ and $X_2$ to calculate and store the cdf's and quantile functions of the variables $X_1$, $X_2$, $X_2|X_1$ and $X_1|X_2$ for both subsets $S=0$ and $S=1$. This approach allows us to apply these functions to individuals based on their positions within the grids, rather than having to compute them each time. Instead of first calculating the cdf at $X_1=x_1$ and then transporting it, we directly apply the cdf and quantile functions at the corresponding $X_1$ grid position near $x_1$. Then, for transporting $X_2|X_1$, we start by storing the relevant cdf's and quantile functions in a matrix, with rows corresponding to grid values for $X_1$ and columns to grid values for $X_2$. To apply the conditional cdf and quantile function to an individual $(s=0,x_1,x_2)$ i.e., sequential transport, rather than relying on Gaussian weights to define a neighborhood around $x_1$, we define a window of width `h`{.R} around the midpoints of the grid cells for $X_1$ and calculate cdf of $X_2$ on this space.

Here, we redefine the outputs of sequential transport function in order to plot the different grids and associated cdf's for $X_2$ and $X_1$ in both subsets $S=0$ and $S=1$.

```{r redef-sequential-transport-function, message=FALSE, warning=FALSE}
#' Sequential transport
#'
#' @param data dataset with three columns:
#'  - S: sensitive attribute, transport from S_0 to the other group
#'  - X1: first predictor, assumed to be causally linked to S
#'  - X2: second predictor, assumed to be causally linked to S and X1
#' @param S_0 Modality called group 0 to (source distribution)
#' @param number of cells in each dimension (default to 15)
#' @param h small value added to extend the area covered by the grid (default
#'  to .2)
#' @param d neighborhood weight when conditioning by x1 (default to .5)
fonction_transport <- function(data,
                               S_0,
                               n_grid = 15,
                               h = .2,
                               d = .5) {

  # Subset of the data: 0 for Black, 1 for White
  D_SXY_0 <- data[data$S == S_0, ]
  D_SXY_1 <- data[data$S != S_0, ]

  # Coordinates of the cells of the grid on subset of 0 (Black)
  vx1_0 <- seq(min(D_SXY_0$X1) - h, max(D_SXY_0$X1) + h, length = n_grid + 1)
  vx2_0 <- seq(min(D_SXY_0$X2) - h, max(D_SXY_0$X2) + h, length = n_grid + 1)
  # and middle point of the cells
  vx1_0_mid <- (vx1_0[2:(1+n_grid)]+vx1_0[1:(n_grid)]) / 2
  vx2_0_mid <- (vx2_0[2:(1+n_grid)]+vx2_0[1:(n_grid)]) / 2

  # Coordinates of the cells of the grid on subset of 1 (White)
  vx1_1 <- seq(min(D_SXY_1$X1) -h, max(D_SXY_1$X1) + h, length = n_grid + 1)
  vx1_1_mid <- (vx1_1[2:(1 + n_grid)] + vx1_1[1:(n_grid)]) / 2
  # and middle point of the cells
  vx2_1 <- seq(min(D_SXY_1$X2) - h, max(D_SXY_1$X2) + h, length = n_grid + 1)
  vx2_1_mid <- (vx2_1[2:(1 + n_grid)] + vx2_1[1:(n_grid)]) / 2

  # Creation of the grids for the CDF and Quantile function
  # init with NA values
  # One grid for X1 and X2, on both subsets of the data (Black/White)
  F1_0 <- F2_0 <- F1_1 <- F2_1 <- matrix(NA, n_grid, n_grid)
  Q1_0 <- Q2_0 <- Q1_1 <- Q2_1 <- matrix(NA, n_grid, n_grid)

  # Empirical CDF for X1 on subset of Black
  FdR1_0 <- Vectorize(function(x) mean(D_SXY_0$X1 <= x))
  f1_0 <- FdR1_0(vx1_0_mid)
  # Empirical CDF for X2 on subset of Black
  FdR2_0 <- Vectorize(function(x) mean(D_SXY_0$X2 <= x))
  f2_0 <- FdR2_0(vx2_0_mid)
  # Empirical CDF for X1 on subset of White
  FdR1_1 <- Vectorize(function(x) mean(D_SXY_1$X1 <= x))
  f1_1 <- FdR1_1(vx1_1_mid)
  # Empirical CDF for X2 on subset of White
  FdR2_1 <- Vectorize(function(x) mean(D_SXY_1$X2 <= x))
  f2_1 <- FdR2_1(vx2_1_mid)

  u <- (1:n_grid) / (n_grid + 1)
  # Empirical quantiles for X1 on subset of Black
  Qtl1_0 <- Vectorize(function(x) quantile(D_SXY_0$X1, x))
  q1_0 <- Qtl1_0(u)
  # Empirical quantiles for X2 on subset of Black
  Qtl2_0 <- Vectorize(function(x) quantile(D_SXY_0$X2, x))
  q2_0 <- Qtl2_0(u)
  # Empirical quantiles for X1 on subset of White
  Qtl1_1 <- Vectorize(function(x) quantile(D_SXY_1$X1, x))
  q1_1 <- Qtl1_1(u)
  # Empirical quantiles for X2 on subset of White
  Qtl2_1 <- Vectorize(function(x) quantile(D_SXY_1$X2, x))
  q2_1 <- Qtl2_1(u)

  for(i in 1:n_grid) {
    # Subset of Black
    idx1_0 <- which(abs(D_SXY_0$X1 - vx1_0_mid[i]) < d)
    FdR2_0 <- Vectorize(function(x) mean(D_SXY_0$X2[idx1_0] <= x))
    F2_0[, i] <- FdR2_0(vx2_0_mid)
    Qtl2_0 <- Vectorize(function(x) quantile(D_SXY_0$X2[idx1_0], x))
    Q2_0[, i] <- Qtl2_0(u)

    idx2_0 <- which(abs(D_SXY_0$X2 - vx2_0_mid[i]) < d)
    FdR1_0 <- Vectorize(function(x) mean(D_SXY_0$X1[idx2_0] <= x))
    F1_0[, i] <- FdR1_0(vx1_0_mid)
    Qtl1_0 <- Vectorize(function(x) quantile(D_SXY_0$X1[idx2_0], x))
    Q1_0[, i] <- Qtl1_0(u)

    # Subset of White
    idx1_1 <- which(abs(D_SXY_1$X1 - vx1_1_mid[i]) < d)
    FdR2_1 <- Vectorize(function(x) mean(D_SXY_1$X2[idx1_1] <= x))
    F2_1[, i] <- FdR2_1(vx2_1_mid)
    Qtl2_1 <- Vectorize(function(x) quantile(D_SXY_1$X2[idx1_1], x))
    Q2_1[, i] <- Qtl2_1(u)

    idx2_1 <- which(abs(D_SXY_1$X2-vx2_1_mid[i])<d)
    FdR1_1 <- Vectorize(function(x) mean(D_SXY_1$X1[idx2_1] <= x))
    F1_1[, i] <- FdR1_1(vx1_1_mid)
    Qtl1_1 <- Vectorize(function(x) quantile(D_SXY_1$X1[idx2_1], x))
    Q1_1[, i] <- Qtl1_1(u)
  }

  # Transport for X2
  T2 <- function(x2) {
    i <- which.min(abs(vx2_0_mid - x2))
    p <- f2_0[i]
    i <- which.min(abs(u - p))
    x2star <- q2_1[i]
    x2star
  }

  # Transport for X1
  T1 <- function(x1) {
    i <- which.min(abs(vx1_0_mid - x1))
    p <- f1_0[i]
    i <- which.min(abs(u - p))
    x1star <- q1_1[i]
    x1star
  }

  # Transport for X2 conditional on X1
  T2_cond_x1 <- function(x2, x1) {
    k0 <- which.min(abs(vx1_0_mid - x1))
    k1 <- which.min(abs(vx1_1_mid - T1(x1)))
    i <- which.min(abs(vx2_0_mid - x2))
    p <- F2_0[i, k0]
    i <- which.min(abs(u - p))
    x2star <- Q2_1[i, k1]
    x2star
  }

  # Transport for X1 conditional on X2
  T1_cond_x2 <- function(x1, x2) {
    k0 <- which.min(abs(vx2_0_mid - x2))
    k1 <- which.min(abs(vx2_1_mid - x2))
    i <- which.min(abs(vx1_0_mid - x1))
    p <- F1_0[i, k0]
    i <- which.min(abs(u - p))
    x1star <- Q1_1[i, k1]
    x1star
  }

  list(
    Transport_x1 = T1,
    Transport_x2 = T2,
    Transport_x1_cond_x2 = T1_cond_x2,
    Transport_x2_cond_x1 = T2_cond_x1,
    vx1_0 = vx1_0,
    vx1_0_mid = vx1_0_mid,
    vx1_1 = vx1_1,
    vx1_1_mid = vx1_1_mid,
    vx2_0 = vx2_0,
    vx2_1 = vx2_1,
    f1_0 = f1_0,
    f1_1 = f1_1,
    F2_0 = F2_0,
    F2_1 = F2_1
  )
}

# Application on the Gaussian database
n_grid <- 15
seq_functions_grids <- fonction_transport(D_SXY, S_0 = S_0, n_grid = n_grid)

```

We first depict the grid for $X_1$, computed on our Gaussian database, with the associated cdf's in subsets $S=0$ and $S=1$.

```{r plot-cdf-grid-x1, fig.height = 5, fig.width = 5, fig.align = "center", dev.args = list(bg = 'transparent'), message=FALSE, warning=FALSE}

# Grid for X1 in subset S=0
vx1_0 <- seq_functions_grids$vx1_0
# Midpoints of the cells
vx1_0_mid <- seq_functions_grids$vx1_0_mid
# cdf (marginal) of X1 in subset S=0
f1_0 <- seq_functions_grids$f1_0

# Grid for X1 in subset S=1
vx1_1 <- seq_functions_grids$vx1_1
# Midpoints of the cells
vx1_1_mid <- seq_functions_grids$vx1_1_mid
# cdf (marginal) of X1 in subset S=1
f1_1 <- seq_functions_grids$f1_1

# Add x-axis
par(mar = c(2,2,0,0))
plot(d_0$x, d_0$x*0, xlab = "", ylab = "", 
     axes = FALSE, col = NA, ylim = c(.5, 2.5))
axis(1)
# Plot the cdf of X1 in subset S=0 with color scale
for(i in 1:n_grid) {
  rect(vx1_0[i], .7, vx1_0[i+1], 0.6,
       col = scales::alpha(COLORS["A"], f1_0[i]),
       border = "grey")
}
# Plot the cdf of X1 in subset S=1 with color scale
for(i in 1:n_grid) {
  rect(vx1_1[i], .8, vx1_1[i+1], .9,
       col = scales::alpha(COLORS["B"], f1_1[i]),
       border = "grey")
}

```
Next we display the matrices of cdf's for $X_2|X_1$ in both subsets $S=0$ and $S=1$:

```{r cdf-grid-x2cx1, fig.height = 5, fig.width = 5, fig.align = "center", dev.args = list(bg = 'transparent'), message=FALSE, warning=FALSE}

# Grid for X2 in subset S=0
vx2_0 <- seq_functions_grids$vx2_0
# cdf (conditional) of X2|X1 in subset S=0 (matrix)
F2_0 <- seq_functions_grids$F2_0

# Grid for X2 in subset S=1
vx2_1 <- seq_functions_grids$vx2_1
# cdf (conditional) of X2|X1 in subset S=1 (matrix)
F2_1 <- seq_functions_grids$F2_1
```

First, we plot the matrix for subset $S=0$ and highlight the column corresponding to the cdf of $X_2|X_1=x_1$ for our example individual:

```{r plot-cdf-grid-x2cx1-0, fig.height = 5, fig.width = 5, fig.align = "center", dev.args = list(bg = 'transparent'), message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: Display the codes used to create the Figure

# Add x-axis and y-axis (for the matrices with cdf's)
par(mar = c(2,2,0,0))
plot(d_0$x, d_0$x, xlab = "", ylab = "", axes = FALSE, col = NA)
axis(1)
axis(2)

# Add grid matrix of cdf's for X2|X1 in subset S=0
for(i in 1:n_grid) {
  for(j in 1:n_grid) {
    rect(vx1_0[i], vx2_0[j], vx1_0[i+1], vx2_0[j+1],
         border="grey")
  }
}
# Column corresponding to X1=x1
i <- which.min(abs(vx1_0_mid-x1))
for(j in 1:n_grid) {
  rect(vx1_0[i], vx2_0[j], vx1_0[i+1], vx2_0[j+1],
       col = scales::alpha(COLORS["A"], F2_0[j,i]),
       border="grey")
}
```
Next, we plot the matrix for subset $S=1$ and highlight the column corresponding to the cdf of $X_2|X_1=x_1^*$ for our example individual:

```{r plot-cdf-grid-x2cx1-1, fig.height = 5, fig.width = 5, fig.align = "center", dev.args = list(bg = 'transparent'), message=FALSE, warning=FALSE}

# Add x-axis and y-axis (for the matrices with cdf's)
par(mar = c(2,2,0,0))
plot(d_1$x, d_1$x, xlab = "", ylab = "", axes = FALSE, col = NA)
axis(1)
axis(2)

# Add grid matrix of cdf's for X2|X1 in subset S=1
for(i in 1:n_grid) {
  for(j in 1:n_grid) {
    rect(vx1_1[i], vx2_1[j], vx1_1[i+1], vx2_1[j+1],
         border = "grey")
  }
}
# Column corresponding to X1=x1_star (i.e., x1 transported)
i <- which.min(abs(vx1_1_mid - x1_star))
for(j in 1:n_grid) {
  rect(vx1_1[i], vx2_1[j], vx1_1[i+1], vx2_1[j+1],
       col = scales::alpha(COLORS["B"], F2_1[j,i]),
       border = "grey")
}

```
