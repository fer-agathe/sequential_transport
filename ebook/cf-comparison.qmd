# Counterfactuals: comparison {#sec-cf-comparison}



::: callout-note

## Objectives

This chapter compares the different methods used to create counterfactuals by examining the impacts on the new predictions made by the classifiers (aware and unaware).

:::



```{r setup, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: Required packages and definition of colours.

# Required packages----
library(tidyverse)
library(fairadapt)

# Graphs----
font_main = font_title = 'Times New Roman'
extrafont::loadfonts(quiet = T)
face_text='plain'
face_title='plain'
size_title = 14
size_text = 11
legend_size = 11

global_theme <- function() {
  theme_minimal() %+replace%
    theme(
      text = element_text(family = font_main, size = size_text, face = face_text),
      legend.text = element_text(family = font_main, size = legend_size),
      axis.text = element_text(size = size_text, face = face_text), 
      plot.title = element_text(
        family = font_title, 
        size = size_title, 
        hjust = 0.5
      ),
      plot.subtitle = element_text(hjust = 0.5)
    )
}

# Seed
set.seed(2025)

colours_all <- c(
  "Factual" = "black",
  "Source" = "#00A08A",
  "Reference" = "#F2AD00",
  "Naive" = "gray",
  "OT" = "#0072B2",
  "Fairadapt" = '#D55E00',
  "Seq. T." = "#CC79A7"
)
```

## Load Data and Classifier

We load the dataset where the sensitive attribute (\(S\)) is the race, obtained [Chapter -@sec-data-save]:
```{r}
load("../data/df_race.rda")
```

Naive counterfactuals constructed when simply changing the sensitive attribute of individuals from the minority group, and predictions by the classifiers (see [Chapter -@sec-cf-naive]):
```{r}
load("../data/counterfactuals_aware_naive_black.rda")
load("../data/counterfactuals_unaware_naive_black.rda")
```

Counterfactuals constructed with fairadapt and predictions by the classifiers (see [Chapter -@sec-cf-fairadapt]):
```{r}
load("../data/counterfactuals_aware_fpt_black.rda")
load("../data/counterfactuals_unaware_fpt_black.rda")
```

Counterfactuals constructed with multivariate optimal transport and predictions by the classifiers (see [Chapter -@sec-cf-ot]):
```{r}
load("../data/counterfactuals_aware_ot_black.rda")
load("../data/counterfactuals_unaware_ot_black.rda")
```

Counterfactuals constructed with sequential transport and predictions by the classifiers (see [Chapter -@sec-cf-seq-t]):
```{r}
load("../data/counterfactuals_aware_seq_black.rda")
load("../data/counterfactuals_unaware_seq_black.rda")
```

We also need the predictions made by the classifier (see [Chapter -@sec-classifier]):
```{r}
# Predictions on train/test sets
load("../data/pred_aware.rda")
load("../data/pred_unaware.rda")
# Predictions on the factuals, on the whole dataset
load("../data/pred_aware_all.rda")
load("../data/pred_unaware_all.rda")
```

We create a tibble with the factuals and the predictions by the aware model, an another with the predictions by the unaware model:
```{r define-factuals_aware}
factuals_aware <- tibble(
  S = df_race$S,
  S_origin = df_race$S,
  X1 = df_race$X1,
  X2 = df_race$X2,
  pred = pred_aware_all,
  type = "factual"
) |> 
  mutate(id_indiv = row_number())

factuals_unaware <- tibble(
  S = df_race$S,
  S_origin = df_race$S,
  X1 = df_race$X1,
  X2 = df_race$X2,
  pred = pred_unaware_all,
  type = "factual"
) |> 
  mutate(id_indiv = row_number())
```


## Comparison


Let us focus on the first three Black individuals from the dataset. We will compare the predicted values by the classifier (see [Chapter -@sec-classifier]) made using the observed characteristics, and the changes in the predictions when using counterfactuals. We use the three types of counterfactuals explored in the previous chapters.

:::{.panel-tabset}

### Unaware Model

```{r}
tb_unaware <- 
  factuals_unaware |> mutate(counterfactual = "none") |>
  # Naive
  bind_rows(counterfactuals_unaware_naive_black |> mutate(counterfactual = "naive")) |> 
  # Multivariate optimal transport
  bind_rows(counterfactuals_unaware_ot_black |> mutate(counterfactual = "ot")) |> 
  # Fairadapt
  bind_rows(counterfactuals_unaware_fpt_black |> mutate(counterfactual = "fpt")) |> 
  # Sequential transport
  bind_rows(counterfactuals_unaware_seq_black |> mutate(counterfactual = "seq"))

tb_indiv_unaware <- 
  tb_unaware |> 
  filter(id_indiv %in% counterfactuals_unaware_seq_black$id_indiv[1:3])

tb_indiv_unaware
```




### Aware Model

```{r}
tb_aware <- 
  factuals_aware |> mutate(counterfactual = "none") |> 
  # Naive
  bind_rows(counterfactuals_aware_naive_black |> mutate(counterfactual = "naive")) |> 
  # Multivariate optimal transport
  bind_rows(counterfactuals_aware_ot_black |> mutate(counterfactual = "ot")) |> 
  # Fairadapt
  bind_rows(counterfactuals_aware_fpt_black |> mutate(counterfactual = "fpt")) |> 
  # Sequential transport
  bind_rows(counterfactuals_aware_seq_black |> mutate(counterfactual = "seq"))
  
tb_indiv_aware <- 
  tb_aware |> 
  filter(id_indiv %in% counterfactuals_aware_seq_black$id_indiv[1:3])

tb_indiv_aware
```

:::



:::{.panel-tabset}

### Unaware Model



```{r}
#| fig-cap: Predictions by the unaware model for three Black individuals.
#| label: fig-example-3-black-inviv-unaware
#| fig-width: 6
#| fig-height: 6
#| code-fold: true
#| code-summary: Codes used to create the Figure.
par(mar = c(2, 2, 0, 0))
# Initial characteristics with the unaware model
tb_indiv_unaware_factual <- 
  tb_indiv_unaware |> filter(type == "factual")

range_x1 <- range(tb_indiv_unaware$X1)
expansion_amount_x1 <- .1*range_x1
range_x2 <- range(tb_indiv_unaware$X2)
expansion_amount_x2 <- .05*range_x2



plot(
  x = tb_indiv_unaware_factual$X1,
  y = tb_indiv_unaware_factual$X2,
  col = colours_all[["Factual"]],
  # xlab = "X1 (UGPA)", ylab = "X2 (LSAT)",
  xlab = "", ylab = "",
  xlim = c(range_x1[1] - expansion_amount_x1[1], range_x1[2] + expansion_amount_x1[2]),
  ylim = c(range_x2[1] - expansion_amount_x2[1], range_x2[2] + expansion_amount_x2[2]),
  pch = 19,
  axes = FALSE
)
axis(1)
mtext(expression(X[1]~(UGCA)), side = 1, padj = .5)
axis(2)
mtext(expression(X[2]~(LSAT)), side = 2, padj = 0)
text(
  x = tb_indiv_unaware_factual$X1, 
  y = tb_indiv_unaware_factual$X2 + 1,
  paste0(round(100*tb_indiv_unaware_factual$pred, 2), "%"),
  col = colours_all[["Factual"]]
)
# Transported characteristics with fairadapt
tb_indiv_unaware_fpt <- 
  tb_indiv_unaware |> filter(counterfactual == "fpt")
points(
  x = tb_indiv_unaware_fpt$X1,
  y = tb_indiv_unaware_fpt$X2,
  col = colours_all[["Fairadapt"]],
  xlab = "X1", ylab = "X2",
  pch = 19
)
# x1 then x2
segments(
  x0 = tb_indiv_unaware_factual$X1, 
  y0 = tb_indiv_unaware_factual$X2,
  x1 = tb_indiv_unaware_fpt$X1, 
  y1 = tb_indiv_unaware_factual$X2, 
  col = colours_all[["Fairadapt"]],
  lty = 2
)
segments(
  x0 = tb_indiv_unaware_fpt$X1, 
  y0 = tb_indiv_unaware_factual$X2,
  x1 = tb_indiv_unaware_fpt$X1, 
  y1 = tb_indiv_unaware_fpt$X2, 
  col = colours_all[["Fairadapt"]],
  lty = 2
)
text(
  x = tb_indiv_unaware_fpt$X1, 
  y = tb_indiv_unaware_fpt$X2 + 1,
  paste0(round(100*tb_indiv_unaware_fpt$pred, 2), "%"),
  col = colours_all[["Fairadapt"]]
)

# Naive
tb_indiv_unaware_naive <- 
  tb_indiv_unaware |> filter(counterfactual == "naive")
points(
  x = tb_indiv_unaware_naive$X1,
  y = tb_indiv_unaware_naive$X2,
  col = colours_all[["Naive"]],
  xlab = "X1", ylab = "X2",
  pch = 19
)
segments(
  x0 = tb_indiv_unaware_factual$X1, 
  y0 = tb_indiv_unaware_factual$X2,
  x1 = tb_indiv_unaware_naive$X1, 
  y1 = tb_indiv_unaware_naive$X2, 
  col = colours_all[["Naive"]],
  lty = 2
)
text(
  x = tb_indiv_unaware_naive$X1 + .1,
  y = tb_indiv_unaware_naive$X2,
  paste0(round(100*tb_indiv_unaware_naive$pred, 2), "%"),
  col = colours_all[["Naive"]]
)

# Transported characteristics with OT
tb_indiv_unaware_ot <- 
  tb_indiv_unaware |> filter(counterfactual == "ot")
points(
  x = tb_indiv_unaware_ot$X1,
  y = tb_indiv_unaware_ot$X2,
  col = colours_all[["OT"]],
  xlab = "X1", ylab = "X2",
  pch = 19
)
segments(
  x0 = tb_indiv_unaware_factual$X1, 
  y0 = tb_indiv_unaware_factual$X2,
  x1 = tb_indiv_unaware_ot$X1, 
  y1 = tb_indiv_unaware_ot$X2, 
  col = colours_all[["OT"]],
  lty = 2
)
text(
  x = tb_indiv_unaware_ot$X1 - .15, 
  y = tb_indiv_unaware_ot$X2,
  paste0(round(100*tb_indiv_unaware_ot$pred, 2), "%"),
  col = colours_all[["OT"]]
)

# Transported characteristics with Sequential transport
tb_indiv_unaware_seq <- 
  tb_indiv_unaware |> filter(counterfactual == "seq")
points(
  x = tb_indiv_unaware_seq$X1,
  y = tb_indiv_unaware_seq$X2,
  col = colours_all[["Seq. T."]],
  xlab = "X1", ylab = "X2",
  pch = 19
)
# x1 then x2
segments(
  x0 = tb_indiv_unaware_factual$X1, 
  y0 = tb_indiv_unaware_factual$X2,
  x1 = tb_indiv_unaware_seq$X1, 
  y1 = tb_indiv_unaware_factual$X2, 
  col = colours_all[["Seq. T."]],
  lty = 2
)
segments(
  x0 = tb_indiv_unaware_seq$X1, 
  y0 = tb_indiv_unaware_factual$X2,
  x1 = tb_indiv_unaware_seq$X1, 
  y1 = tb_indiv_unaware_seq$X2, 
  col = colours_all[["Seq. T."]],
  lty = 2
)
text(
  x = tb_indiv_unaware_seq$X1 + .11, 
  y = tb_indiv_unaware_seq$X2 - .5,
  paste0(round(100*tb_indiv_unaware_seq$pred, 2), "%"),
  col = colours_all[["Seq. T."]]
)
legend(
  "topleft", 
  pch = 19, col = colours_all[c("Factual", "Naive", "OT", "Fairadapt", "Seq. T.")], 
  legend = names(colours_all[c("Factual", "Naive", "OT", "Fairadapt", "Seq. T.")]),
  box.lty=0
)

```

### Aware Model


```{r}
#| fig-cap: Predictions by the aware model for three Black individuals.
#| label: fig-example-3-black-inviv-aware
#| fig-width: 6
#| fig-height: 6
#| code-fold: true
#| code-summary: Codes used to create the Figure.
par(mar = c(2, 2, 0, 0))
# Initial characteristics with the aware model
tb_indiv_aware_factual <- 
  tb_indiv_aware |> filter(type == "factual")

range_x1 <- range(tb_indiv_aware$X1)
expansion_amount_x1 <- .1*range_x1
range_x2 <- range(tb_indiv_aware$X2)
expansion_amount_x2 <- .05*range_x2

plot(
  x = tb_indiv_aware_factual$X1,
  y = tb_indiv_aware_factual$X2,
  col = colours_all[["Factual"]],
  xlab = "", ylab = "",
  # xlab = "X1 (UGPA)", ylab = "X2 (LSAT)",
  xlim = c(range_x1[1] - expansion_amount_x1[1], range_x1[2] + expansion_amount_x1[2]),
  ylim = c(range_x2[1] - expansion_amount_x2[1], range_x2[2] + expansion_amount_x2[2]),
  pch = 19,
  axes = FALSE
)
axis(1)
mtext(expression(X[1]~(UGCA)), side = 1, padj = .5)
axis(2)
mtext(expression(X[2]~(LSAT)), side = 2, padj = 0)
text(
  x = tb_indiv_aware_factual$X1, 
  y = tb_indiv_aware_factual$X2 + 1,
  paste0(round(100*tb_indiv_aware_factual$pred, 2), "%"),
  col = colours_all[["Factual"]]
)

# Naive
tb_indiv_aware_naive <- 
  tb_indiv_aware |> filter(counterfactual == "naive")
points(
  x = tb_indiv_aware_naive$X1,
  y = tb_indiv_aware_naive$X2,
  col = colours_all[["Naive"]],
  xlab = "X1", ylab = "X2",
  pch = 19
)
segments(
  x0 = tb_indiv_aware_factual$X1, 
  y0 = tb_indiv_aware_factual$X2,
  x1 = tb_indiv_aware_naive$X1, 
  y1 = tb_indiv_aware_naive$X2, 
  col = colours_all[["Naive"]],
  lty = 2
)
text(
  x = tb_indiv_aware_naive$X1 - .1,
  y = tb_indiv_aware_naive$X2,
  paste0(round(100*tb_indiv_aware_naive$pred, 2), "%"),
  col = colours_all[["Naive"]]
)

# Transported characteristics with fairadapt
tb_indiv_aware_fpt <- 
  tb_indiv_aware |> filter(counterfactual == "fpt")
points(
  x = tb_indiv_aware_fpt$X1,
  y = tb_indiv_aware_fpt$X2,
  col = colours_all[["Fairadapt"]],
  xlab = "X1", ylab = "X2",
  pch = 19
)
# x1 then x2
segments(
  x0 = tb_indiv_aware_factual$X1, 
  y0 = tb_indiv_aware_factual$X2,
  x1 = tb_indiv_aware_fpt$X1, 
  y1 = tb_indiv_aware_factual$X2, 
  col = colours_all[["Fairadapt"]],
  lty = 2
)
segments(
  x0 = tb_indiv_aware_fpt$X1, 
  y0 = tb_indiv_aware_factual$X2,
  x1 = tb_indiv_aware_fpt$X1, 
  y1 = tb_indiv_aware_fpt$X2, 
  col = colours_all[["Fairadapt"]],
  lty = 2
)
text(
  x = tb_indiv_aware_fpt$X1, 
  y = tb_indiv_aware_fpt$X2 + 1,
  paste0(round(100*tb_indiv_aware_fpt$pred, 2), "%"),
  col = colours_all[["Fairadapt"]]
)
# Transported characteristics with OT
tb_indiv_aware_ot <- 
  tb_indiv_aware |> filter(counterfactual == "ot")
points(
  x = tb_indiv_aware_ot$X1,
  y = tb_indiv_aware_ot$X2,
  col = colours_all[["OT"]],
  xlab = "X1", ylab = "X2",
  pch = 19
)
# x1 then x2
segments(
  x0 = tb_indiv_aware_factual$X1, 
  y0 = tb_indiv_aware_factual$X2,
  x1 = tb_indiv_aware_ot$X1, 
  y1 = tb_indiv_aware_ot$X2, 
  col = colours_all[["OT"]],
  lty = 2
)
text(
  x = tb_indiv_aware_ot$X1 - .15, 
  y = tb_indiv_aware_ot$X2,
  paste0(round(100*tb_indiv_aware_ot$pred, 2), "%"),
  col = colours_all[["OT"]]
)

# Transported characteristics with Sequential transport
tb_indiv_aware_seq <- 
  tb_indiv_aware |> filter(counterfactual == "seq")
points(
  x = tb_indiv_aware_seq$X1,
  y = tb_indiv_aware_seq$X2,
  col = colours_all[["Seq. T."]],
  xlab = "X1", ylab = "X2",
  pch = 19
)
# x1 then x2
segments(
  x0 = tb_indiv_aware_factual$X1, 
  y0 = tb_indiv_aware_factual$X2,
  x1 = tb_indiv_aware_seq$X1, 
  y1 = tb_indiv_aware_factual$X2, 
  col = colours_all[["Seq. T."]],
  lty = 2
)
segments(
  x0 = tb_indiv_aware_seq$X1, 
  y0 = tb_indiv_aware_factual$X2,
  x1 = tb_indiv_aware_seq$X1, 
  y1 = tb_indiv_aware_seq$X2, 
  col = colours_all[["Seq. T."]],
  lty = 2
)
text(
  x = tb_indiv_aware_seq$X1 - .11, 
  y = tb_indiv_aware_seq$X2 - 1,
  paste0(round(100*tb_indiv_aware_seq$pred, 2), "%"),
  col = colours_all[["Seq. T."]]
)
legend(
  "topleft", 
  pch = 19, col = colours_all[c("Factual", "Naive", "OT", "Fairadapt", "Seq. T.")], 
  legend = names(colours_all[c("Factual", "Naive", "OT", "Fairadapt", "Seq. T.")]),
  box.lty=0, bg = "transparent"
)
```


:::


## Densities

Let us now compare the densities of the predicted values.

```{r define-colours}
colours <- c(
  "0" = "#5BBCD6",
  "1" = "#FF0000",
  "A" = "#00A08A",
  "B" = "#F2AD00",
  "with" = "#046C9A",
  "without" = "#C93312",
  "2" = "#0B775E"
)
```

:::{.panel-tabset}

### Unaware model

```{r}
#| fig-cap: Densities of predicted scores for Black individuals with factuals and with counterfactuals. The yellow dashed line corresponds to the density of predicted scores for White individuals, using factuals.
#| label: fig-densities-counterfactuals-unaware
#| fig-width: 4
#| fig-height: 4
#| code-fold: true
#| code-summary: Codes used to create the Figure.
# Factuals
tb_unaware_factuals <- tb_unaware |> 
  filter(counterfactual == "none")
# Predicted values
pred_unaware_factuals_black <- tb_unaware_factuals |> filter(S == "Black") |> pull("pred")
pred_unaware_factuals_white <- tb_unaware_factuals |> filter(S == "White") |> pull("pred")
# Estimated densities
d_unaware_factuals_black <- density(pred_unaware_factuals_black)
d_unaware_factuals_white <- density(pred_unaware_factuals_white)

par(mfrow = c(4, 1), mar = c(2, 2, 0, 0))
x_lim <- c(0, .8)
y_lim <- c(0, 8)

# OT
tb_unaware_ot <- tb_unaware |> filter(counterfactual == "ot")
# Predicted values, focusing on Black --> White
pred_unaware_ot_black_star <- tb_unaware_ot |> filter(S == "White") |> pull("pred")
# Estimated densities
d_unaware_ot_black_star <- density(pred_unaware_ot_black_star)

plot(
  d_unaware_factuals_black,
  main = "", xlab = "", ylab = "",
  axes = FALSE, col = NA,
  xlim = x_lim, ylim = y_lim
)
axis(1)
axis(2)
polygon(d_unaware_factuals_black, col = alpha(colours_all[["Source"]], .5), border = NA)
lines(d_unaware_factuals_white, col = colours_all[["Reference"]], lty = 2, lwd = 2)
polygon(d_unaware_ot_black_star, col = alpha(colours_all[["OT"]], .5), border = NA)
text(x = .15, y = 6, "Factuals - Black", col = colours_all[["Source"]])
pos_arrow <- .2
ind_min <- which.min(abs(d_unaware_factuals_black$x - pos_arrow))
arrows(
  x1 = d_unaware_factuals_black$x[ind_min],
  y1 = d_unaware_factuals_black$y[ind_min],
  x0 = .15, 
  y0 = 5,
  length = 0.05, col = colours_all[["Source"]]
)
text(x = .53, y = 6, "Multi. OT", col = colours_all[["OT"]])
pos_arrow_ref <- .7
text(x = pos_arrow_ref, y = 6, "Factuals - White", col = colours_all[["Reference"]])
ind_min_ref <- which.min(abs(d_unaware_factuals_white$x - pos_arrow_ref))
arrows(
  x1 = d_unaware_factuals_white$x[ind_min_ref],
  y1 = d_unaware_factuals_white$y[ind_min_ref],
  x0 = pos_arrow_ref, 
  y0 = 5,
  length = 0.05, col = colours_all[["Reference"]]
)

# Naive
tb_unaware_naive <- tb_unaware |> filter(counterfactual == "naive")
# Predicted values, focusing on Black --> White
pred_unaware_naive_black_star <- tb_unaware_naive |> filter(S == "White") |> pull("pred")
# Estimated densities
d_unaware_naive_black_star <- density(pred_unaware_naive_black_star)

plot(
  d_unaware_factuals_black,
  main = "", xlab = "", ylab = "",
  axes = FALSE, col = NA,
  xlim = x_lim, ylim = y_lim
)
axis(1)
axis(2)
polygon(d_unaware_factuals_black, col = alpha(colours_all[["Source"]], .5), border = NA)
lines(d_unaware_factuals_white, col = colours_all[["Reference"]], lty = 2, lwd = 2)
polygon(d_unaware_naive_black_star, col = alpha(colours_all[["Naive"]], .5), border = NA)
text(x = .28, y = 6, "Naive", col = colours_all[["Naive"]])


# Fairadapt
tb_unaware_fpt <- tb_unaware |> filter(counterfactual == "fpt")
# Predicted values, focusing on Black --> White
pred_unaware_fpt_black_star <- 
  tb_unaware_fpt |> filter(S == "White") |> pull("pred")
# Estimated densities
d_unaware_fpt_black_star <- density(pred_unaware_fpt_black_star)

plot(
  d_unaware_factuals_black,
  main = "", xlab = "", ylab = "",
  axes = FALSE, col = NA,
  xlim = x_lim, ylim = y_lim
)
axis(1)
axis(2)
polygon(d_unaware_factuals_black, col = alpha(colours_all[["Source"]], .5), border = NA)
lines(d_unaware_factuals_white, col = colours_all[["Reference"]], lty = 2, lwd = 2)
polygon(d_unaware_fpt_black_star, col = alpha(colours_all[["Fairadapt"]], .5), border = NA)
text(x = .53, y = 6, "fairadapt", col = colours_all[["Fairadapt"]])


# Sequential transport
tb_unaware_seq <- tb_unaware |> filter(counterfactual == "seq")
# Predicted values, focusing on Black --> White
pred_unaware_seq_black_star <- tb_unaware_seq |> filter(S == "White") |> pull("pred")
# Estimated densities
d_unaware_seq_black_star <- density(pred_unaware_seq_black_star)

plot(
  d_unaware_factuals_black,
  main = "", xlab = "", ylab = "",
  axes = FALSE, col = NA,
  xlim = x_lim, ylim = y_lim
)
axis(1)
axis(2)
polygon(d_unaware_factuals_black, col = alpha(colours_all[["Source"]], .5), border = NA)
lines(d_unaware_factuals_white, col = colours_all[["Reference"]], lty = 2, lwd = 2)
polygon(d_unaware_seq_black_star, col = alpha(colours_all[["Seq. T."]], .5), border = NA)
text(x = .53, y = 6, "Seq. T.", col = colours_all[["Seq. T."]])
```

### Aware model

```{r}
#| fig-cap: Densities of predicted scores for Black individuals with factuals and with counterfactuals. The yellow dashed line corresponds to the density of predicted scores for White individuals, using factuals.
#| label: fig-densities-counterfactuals-aware
#| fig-width: 4
#| fig-height: 4
#| code-fold: true
#| code-summary: Codes used to create the Figure.
# Factuals
tb_aware_factuals <- tb_aware |> 
  filter(counterfactual == "none")
# Predicted values
pred_aware_factuals_black <- tb_aware_factuals |> filter(S == "Black") |> pull("pred")
pred_aware_factuals_white <- tb_aware_factuals |> filter(S == "White") |> pull("pred")
# Estimated densities
d_aware_factuals_black <- density(pred_aware_factuals_black)
d_aware_factuals_white <- density(pred_aware_factuals_white)

par(mfrow = c(4, 1), mar = c(2, 2, 0, 0))
x_lim <- c(0, .8)
y_lim <- c(0, 8)

# OT
tb_aware_ot <- tb_aware |> filter(counterfactual == "ot")
# Predicted values, focusing on Black --> White
pred_aware_ot_black_star <- tb_aware_ot |> filter(S == "White") |> pull("pred")
# Estimated densities
d_aware_ot_black_star <- density(pred_aware_ot_black_star)

plot(
  d_aware_factuals_black,
  main = "", xlab = "", ylab = "",
  axes = FALSE, col = NA,
  xlim = x_lim, ylim = y_lim
)
axis(1)
axis(2)
polygon(d_aware_factuals_black, col = alpha(colours_all[["Source"]], .5), border = NA)
lines(d_aware_factuals_white, col = colours_all[["Reference"]], lty = 2, lwd = 2)
polygon(d_aware_ot_black_star, col = alpha(colours_all[["OT"]], .5), border = NA)
text(x = .25, y = 6, "Factuals - Black", col = colours_all[["Source"]])
pos_arrow <- .2
ind_min <- which.min(abs(d_aware_factuals_black$x - .2))
arrows(
  x1 = d_aware_factuals_black$x[ind_min],
  y1 = d_aware_factuals_black$y[ind_min],
  x0 = .25, 
  y0 = 5,
  length = 0.05, col = colours_all[["Source"]]
)
pos_arrow_ref <- .7
text(x = pos_arrow_ref, y = 6, "Factuals - White", col = colours_all[["Reference"]])
ind_min_ref <- which.min(abs(d_aware_factuals_white$x - pos_arrow_ref))
arrows(
  x1 = d_aware_factuals_white$x[ind_min_ref],
  y1 = d_aware_factuals_white$y[ind_min_ref],
  x0 = pos_arrow_ref, 
  y0 = 5,
  length = 0.05, col = colours_all[["Reference"]]
)
text(x = .53, y = 6, "Multi. OT", col = colours_all[["OT"]])

# Naive
tb_aware_naive <- tb_aware |> filter(counterfactual == "naive")
# Predicted values, focusing on Black --> White
pred_aware_naive_black_star <- tb_aware_naive |> filter(S == "White") |> pull("pred")
# Estimated densities
d_aware_naive_black_star <- density(pred_aware_naive_black_star)

plot(
  d_aware_factuals_black,
  main = "", xlab = "", ylab = "",
  axes = FALSE, col = NA,
  xlim = x_lim, ylim = y_lim
)
axis(1)
axis(2)
polygon(d_aware_factuals_black, col = alpha(colours_all[["Source"]], .5), border = NA)
lines(d_aware_factuals_white, col = colours_all[["Reference"]], lty = 2, lwd = 2)
polygon(d_aware_naive_black_star, col = alpha(colours_all[["Naive"]], .5), border = NA)
text(x = .35, y = 6, "Naive", col = colours_all[["Naive"]])


# Fairadapt
tb_aware_fpt <- tb_aware |> filter(counterfactual == "fpt")
# Predicted values, focusing on Black --> White
pred_aware_fpt_black_star <- 
  tb_aware_fpt |> filter(S == "White") |> pull("pred")
# Estimated densities
d_aware_fpt_black_star <- density(pred_aware_fpt_black_star)

plot(
  d_aware_factuals_black,
  main = "", xlab = "", ylab = "",
  axes = FALSE, col = NA,
  xlim = x_lim, ylim = y_lim
)
axis(1)
axis(2)
polygon(d_aware_factuals_black, col = alpha(colours_all[["Source"]], .5), border = NA)
lines(d_aware_factuals_white, col = colours_all[["Reference"]], lty = 2, lwd = 2)
polygon(d_aware_fpt_black_star, col = alpha(colours_all[["Fairadapt"]], .5), border = NA)
text(x = .53, y = 6, "fairadapt", col = colours_all[["Fairadapt"]])


# Sequential transport
tb_aware_seq <- tb_aware |> filter(counterfactual == "seq")
# Predicted values, focusing on Black --> White
pred_aware_seq_black_star <- tb_aware_seq |> filter(S == "White") |> pull("pred")
# Estimated densities
d_aware_seq_black_star <- density(pred_aware_seq_black_star)

plot(
  d_aware_factuals_black,
  main = "", xlab = "", ylab = "",
  axes = FALSE, col = NA,
  xlim = x_lim, ylim = y_lim
)
axis(1)
axis(2)
polygon(d_aware_factuals_black, col = alpha(colours_all[["Source"]], .5), border = NA)
lines(d_aware_factuals_white, col = colours_all[["Reference"]], lty = 2, lwd = 2)
polygon(d_aware_seq_black_star, col = alpha(colours_all[["Seq. T."]], .5), border = NA)
text(x = .53, y = 6, "Seq. T.", col = colours_all[["Seq. T."]])
```


:::

## Metrics


We load the dataset on which the classifiers were trained (see [Chapter -@sec-classifier]).
```{r load-df_race_c}
load("../data/df_race_c.rda")
```


The predictions by the model using the factuals are stored in `factuals_aware` and `factuals_unaware`.



We define a small function, `get_prob()`{.R}, to compute the average score predicted by the model (either the aware model or the unaware model) in sub-groups identified by positions of observations.
```{r define-get_prob}
#| code-fold: true
#| code-summary: The `get_prob()`{.R} function.
get_prob <- function(type, model = "aware", ind, sensitive = "Black") {
  if (type == "factual") {
    x <- get(paste0("factuals_", model))
  } else if (type == "naive") {
    x <- get(paste0("counterfactuals_", model, "_naive_black"))
  } else if (type == "fairadapt") {
    x <- get(paste0("counterfactuals_", model, "_fpt_black"))
  } else if (type == "ot") {
    x <- get(paste0("counterfactuals_", model, "_ot_black"))
  } else if (type == "seq") {
    x <- get(paste0("counterfactuals_", model, "_seq_black"))
  } else {
    stop("Error type.")
  }
  
  val <- x |> filter(id_indiv %in% ind) |> pull("pred")
  
  tribble(
    ~type, ~model, ~sensitive, ~value_type, ~value,
    type, model, sensitive, "mean", mean(val),
    type, model, sensitive, "sd", sd(val)
  )
}
```

We identify the following sub-groups:

```{r define-subgroups}
df_race_c <- df_race_c |> mutate(id_indiv = row_number())
ind_black <- df_race_c |> filter(S == "Black") |> pull("id_indiv")
ind_white <- df_race_c |> filter(S == "White") |> pull("id_indiv")
ind_pos <- df_race_c |> filter(Y == 1) |> pull("id_indiv")
ind_neg <- df_race_c |> filter(Y == 0) |> pull("id_indiv")
ind_true_pos <- intersect(ind_pos, ind_black)
ind_pos_black <- intersect(ind_pos, ind_black)
ind_pos_white <- intersect(ind_pos, ind_white)
ind_neg_black <- intersect(ind_neg, ind_black)
ind_neg_white <- intersect(ind_neg, ind_white)
```


Then, we compute the three metrics and merge them in a single table:
```{r define-conditional_demographic_parity}
conditional_demographic_parity <- NULL
eq_op_pos <- NULL
eq_op_neg <- NULL
for (type in c("factual", "naive","ot", "fairadapt", "seq")) {
  for (model in c("aware", "unaware")) {
    if (type == "factual") {
      for (sensitive in c("Black", "White")) {
        # Conditional Demographic Parity
        tmp_cdp <- 
          get_prob(type = type, model = model, ind = ind_black) |> 
          bind_rows(
            get_prob(
              type = type, model = model, ind = ind_white, sensitive = "White"
              )
          )
        # ~ Equal Opportunity for Y=1
        tmp_eq_op_pos <- 
          get_prob(type = type, model = model, ind = ind_pos_black) |> 
          bind_rows(
            get_prob(
              type = type, model = model, ind = ind_pos_white, 
              sensitive = "White"
              )
          )
        # ~ Equal Opportunity for Y=0
        tmp_eq_op_neg <- 
          get_prob(type = type, model = model, ind = ind_neg_black) |> 
          bind_rows(
            get_prob(
              type = type, model = model, ind = ind_neg_white, 
              sensitive = "White"
              )
          )
      } 
    } else {
      tmp_cdp <- get_prob(type = type, model = model, ind = ind_black)
      tmp_eq_op_pos <- get_prob(type = type, model = model, ind = ind_pos_black)
      tmp_eq_op_neg <- get_prob(type = type, model = model, ind = ind_neg_black)
    }
    conditional_demographic_parity <- 
      bind_rows(conditional_demographic_parity, tmp_cdp)
    eq_op_pos <- bind_rows(eq_op_pos, tmp_eq_op_pos)
    eq_op_neg <- bind_rows(eq_op_neg, tmp_eq_op_neg)
  }
}

# Merge those in a single table:
metrics <- 
  conditional_demographic_parity |> mutate(metric = "CDP") |> 
  bind_rows(eq_op_pos |> mutate(metric = "Eq. Opp. Y=1")) |> 
  bind_rows(eq_op_neg |> mutate(metric = "Eq. Opp. Y=0"))

```




```{r}
#| code-fold: true
#| code-summary: Codes used to create the Table.
#| tbl-cap: Fairness metrics computed on scores predicted by the classifier based on the factuals or the different versions of the counterfactuals, for the aware model (sensitive variable used to train the classifier) and the unaware model (sentitive variable not provided to train the classifier).
#| label: tbl-fairness-metrics-lawschool
# digits <- 2
num_accuracy <- 0.01
tb_res <- 
  metrics |> 
  mutate(type = ifelse(
    type == "factual" & sensitive == "White", "factual_white", type),
    type = factor(
      type, 
      levels = c("factual_white", "factual", "naive", "ot", "fairadapt", "seq")
    )
  ) |> 
  select(-sensitive) |> 
  pivot_wider(names_from = "value_type", values_from = "value") |> 
  mutate(value = paste0(
    scales::number(mean, accuracy = num_accuracy),
    " (",
    scales::number(sd, accuracy = num_accuracy),
    ")")
  ) |> 
  select(-mean, -sd) |> 
  pivot_wider(names_from = "type", values_from = "value", names_sort = TRUE) |> 
  arrange(model, metric)

knitr::kable(
  tb_res[, -1], 
  col.names = c("Metric", "Factual", "Factual", "Naive", "OT", "Fairadapt", "Seq. Transport")
) |> 
  kableExtra::kable_styling("striped", full_width = F) %>%
  kableExtra::add_header_above(
    c(" " = 1, "White"=1, "Black"=5)
  ) |> 
  kableExtra::pack_rows(index = table(tb_res$model))
```


```{r, eval=FALSE}
#| code-fold: true
#| code-summary: LaTeX Table
knitr::kable(
  tb_res[,-1], format = "latex", booktabs = TRUE
) |> 
  kableExtra::kable_styling("striped", full_width = F) %>%
  kableExtra::add_header_above(
    c(" " = 1, "White"=1, "Black"=5)
  ) |> 
  kableExtra::pack_rows(index = table(tb_res$model))

```
