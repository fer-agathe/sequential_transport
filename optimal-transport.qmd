# Optimal Transport {#sec-optimal-transport}

::: callout-note

## Objectives

This chapter demonstrates Optimal Transport (OT) methodology applied to simulated Gaussian and general marginal distributions. The sensitive attribute $S \in \left\{0,1\right\}$ is a binary variable, with each group $S=0$ and $S=1$, corresponding to a distinct Gaussian or general distribution. The objective is to transport, with OT theory, $\boldsymbol{X} = (X_1,X_2)$ from group $S=0$ to group $S=1$.

:::

```{r setup, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: Display the setting codes

# Required packages----
library(tidyverse)
library(glue)
library(igraph)
library("wesanderson")
library(scales)
library(kableExtra)
library(InsurFair)
library(expm)
library(ks)

# Graphs----
data("COLORS")
colors = COLORS

# Seed
set.seed(1234)

source("functions/utils.R")
source("functions/graphs.R")
```

## Univariate Optimal Transport

### Gaussian distribution 

We start by simulating two univariate Gaussian distributions with their densities: one for the subset $S=0$ and one for the subset $S=1$.

```{r data-univ-gauss, message=FALSE, warning=FALSE}

# Univariate Gaussian distribution S=0
x1_grid <- seq(-5, 5, length = 251)
m0 <- -1
s0 <- 1.2
d0x1 <- dnorm(x1_grid, m0, s0)
d_0 <- data.frame(x = x1_grid, y = d0x1)

# Univariate Gaussian distribution S=1
m1 <- 1.5
s1 <- .9
d1x1 <- dnorm(x1_grid, m1, s1)
d_1 <- data.frame(x = x1_grid, y = d1x1)

```

In the following graphs, we plot the optimal transport mapping for one example individual from subset $S=0$:
```{r ot-map-univ-gauss, message=FALSE, warning=FALSE}
u <- 0.1586553
# u-quantile of X1 for subset S=0
x1 <- qnorm(u, m0, s0)
# u-quantile of X1 for subset S=1
x1_star <- qnorm(u, m1, s1)

```

We also calculate the indices of $X_1$ grid that are below this individual ($x_1$) and its counterfactual ($x_1^*$) in order to plot the cdf's (for this individual) of $X_1$ in both subsets $S=0$ and $S=1$ in the following graphs:
```{r indices-univ-gauss-x1, message=FALSE, warning=FALSE}
idx1 <- which(x1_grid <= x1)
idx1_star <- which(x1_grid <= x1_star)

```

We then plot the Optimal Transport line between $X_1|S=0$ and $X_1|S=1$:
```{r plot-ot-univ, fig.height = 4, fig.width = 4, fig.align = "center", dev.args = list(bg = 'transparent'), message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: Display the codes used to create the Figure

# Graph parameters
limA <- c(-5, 5)
limB <- c(-5, 5) 
limY <- c(0, .5)
lab <- c("A", "B")
sub <- 6

{
  mat <- matrix(c(1, 2, 0, 3), 2)
  par(mfrow = c(2, 2))
  layout(mat, c(3.5, 1), c(1, 3))
  par(mar = c(0.5, 4.5, 0.5, 0.5))
}

# Density of X1 in subset S=0
plot(d_0$x, d_0$y, type = "l", col = COLORS[lab[1]], lwd = 2,
     axes = FALSE, xlab = "", ylab = "", xlim = limA, ylim = limY)
polygon(c(0, d_0$x, 1), c(0, d_0$y, 0), 
        col = scales::alpha(COLORS[lab[1]], 0.1), 
        border = NA)
# cdf of X1 in subset S=0
polygon(c(min(d_0$x), d_0$x[idx1], max(d_0$x[idx1])),
        c(0, d_0$y[idx1], 0),
        col = scales::alpha(colors["A"],.2),
        border = NA)
# Add x-axis
axis(1, at = seq(limA[1], limA[2], length = sub), 
     label = c(NA, seq(limA[1], limA[2], length = sub)[-1]))

# Optimal transport from subset S=0 to S=1 (defined with quantile functions)
par(mar = c(4.5, 4.5, 0.5, 0.5))
u_grid <- seq(0, 1, length=261)
q_0 <- qnorm(u_grid, m0, s0)
q_1 <- qnorm(u_grid, m1, s1)
plot(q_0, q_1, col = COLORS["1"], lwd = 2, type = "l", 
     xlab = "", ylab = "", xlim = limA, ylim = limB, axes = FALSE)
abline(a = 0, b = 1, col = COLORS["0"], lty = 2)
# Add x-axis and y-axis
axis(1)
axis(2)
# Legend
mtext("distribution (group 0)", side = 1, line = 3, col = "black")
mtext("distribution (group 1)", side = 2, line = 3, col = "black")
# Example individual
points(x1, x1_star, pch = 19, col = COLORS["1"])
segments(x1, x1_star, x1, 10, lwd = .4, col = COLORS["1"])
segments(x1, x1_star, 10, x1_star, lwd = .4, col = COLORS["1"])

# Density of X1 in subset S=1
par(mar = c(4.5, 0.5, 0.5, 0.5))
plot(d_1$y, d_1$x, type = "l", col = COLORS[lab[2]], lwd = 2,
     ylim = limB, xlim = limY, xlab = "", ylab = "", axes = FALSE)
polygon(c(0, d_1$y, 0), c(0, d_1$x, 1), 
        col = scales::alpha(COLORS[lab[2]], 0.1), border = NA)
# cdf of X1 in subset S=1
polygon(c(0, d_1$y[idx1_star], 0),
        c(min(d_1$x), d_1$x[idx1_star], max(d_1$x[idx1_star])),
        col = scales::alpha(colors["B"],.2),
        border = NA)
# Add y-axis
axis(2, at = seq(limB[1], limB[2], length = sub), 
     label = c(NA, seq(limB[1], limB[2], length = sub)[-c(1, sub)], NA))

```
### General distribution

We simulate two general univariate distributions based on Gaussian distributions with their densities, cdf's and quantile functions: one for the subset $S=0$ and one for the subset $S=1$.

```{r data-univ-general, message=FALSE, warning=FALSE}

# General distribution for subset S=0
x0 <- rnorm(13, m0, s0)
f0 <- density(x0, from = -5, to = 5, n = length(x1_grid))
d0 <- f0$y
d_0 <- data.frame(x = x1_grid, y = d0)
x0s <- sample(x0, size = 1e3, replace = TRUE) + rnorm(1e3, 0, f0$bw)
F0 <- Vectorize(function(x) mean(x0s <= x))
Q0 <- Vectorize(function(x) as.numeric(quantile(x0s, x)))

# General distribution for subset S=1
x1 <- rnorm(7, m1, 1)
f1 <- density(x1, from = -5, to = 5, n = length(x1_grid))
d1 <- f1$y
d_1 <- data.frame(x = x1_grid, y = d1)
x1s <- sample(x1, size = 1e3, replace = TRUE) + rnorm(1e3, 0, f1$bw)
F1 <- Vectorize(function(x) mean(x1s <= x))
Q1 <- Vectorize(function(x) as.numeric(quantile(x1s, x)))

```

In the following graphs, we plot the optimal transport mapping for one example individual from subset $S=0$:
```{r data-univ, message=FALSE, warning=FALSE}
u <- 0.1586553
x1 <- Q0(u)
x1_star <- Q1(u)

```

We also calculate the indices of $X_1$ grid that are below this individual ($x_1$) and its counterfactual ($x_1^*$) in order to plot the cdf's (for this individual) of $X_1$ in both subsets $S=0$ and $S=1$ in the following graphs:
```{r indices-univ-general-x1, message=FALSE, warning=FALSE}
idx1 <- which(x1_grid <= x1)
idx1_star <- which(x1_grid <= x1_star)

```

We then plot the Optimal Transport line between $X_1|S=0$ and $X_1|S=1$:
```{r plot-ot-univ-general, fig.height = 4, fig.width = 4, fig.align = "center", dev.args = list(bg = 'transparent'), message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: Display the codes used to create the Figure

{
  mat <- matrix(c(1, 2, 0, 3), 2)
  par(mfrow = c(2, 2))
  layout(mat, c(3.5, 1), c(1, 3))
  par(mar = c(0.5, 4.5, 0.5, 0.5))
}

# Density of X1 in subset S=0
plot(d_0$x, d_0$y, type = "l", col = COLORS[lab[1]], lwd = 2,
     axes = FALSE, xlab = "", ylab = "", xlim = limA, ylim = limY)
polygon(c(0, d_0$x, 1), c(0, d_0$y, 0), 
        col = scales::alpha(COLORS[lab[1]], 0.1), 
        border = NA)
# cdf of X1 in subset S=0
polygon(c(min(d_0$x), d_0$x[idx1], max(d_0$x[idx1])),
        c(0, d_0$y[idx1], 0),
        col = scales::alpha(colors["A"],.2),
        border = NA)
# Add x-axis
axis(1, at = seq(limA[1], limA[2], length = sub), 
     label = c(NA, seq(limA[1], limA[2], length = sub)[-1]))

# Optimal transport from subset S=0 to S=1 (defined with quantile functions)
par(mar = c(4.5, 4.5, 0.5, 0.5))
u_grid <- seq(0, 1, length=261)
q_0 <- Q0(u_grid)
q_1 <- Q1(u_grid)
plot(q_0, q_1, col = COLORS["1"], lwd = 2, type = "l", 
     xlab = "", ylab = "", xlim = limA, ylim = limB, axes = FALSE)
abline(a = 0, b = 1, col = COLORS["0"], lty = 2)
# Add x-axis and y-axis
axis(1)
axis(2)
# Legend
mtext("distribution (group 0)", side = 1, line = 3, col = "black")
mtext("distribution (group 1)", side = 2, line = 3, col = "black")
# Example individual
points(x1, x1_star, pch = 19, col = COLORS["1"])
segments(x1, x1_star, x1, 10, lwd = .4, col = COLORS["1"])
segments(x1, x1_star, 10, x1_star, lwd = .4, col = COLORS["1"])

# Density of X1 in subset S=1
par(mar = c(4.5, 0.5, 0.5, 0.5))
plot(d_1$y, d_1$x, type = "l", col = COLORS[lab[2]], lwd = 2,
     ylim = limB, xlim = limY, xlab = "", ylab = "", axes = FALSE)
polygon(c(0, d_1$y, 0), c(0, d_1$x, 1), 
        col = scales::alpha(COLORS[lab[2]], 0.1), border = NA)
# cdf of X1 in subset S=1
polygon(c(0, d_1$y[idx1_star], 0),
        c(min(d_1$x), d_1$x[idx1_star], max(d_1$x[idx1_star])),
        col = scales::alpha(colors["B"],.2),
        border = NA)
# Add y-axis
axis(2, at = seq(limB[1], limB[2], length = sub), 
     label = c(NA, seq(limB[1], limB[2], length = sub)[-c(1, sub)], NA))

```
## Multivariate and Conditional Transport

### Gaussian distribution

```{r X1_then_X2, fig.height = 5, fig.width = 5, fig.align = "center", dev.args = list(bg = 'transparent'), echo=FALSE, message=FALSE, warning=FALSE}
par(mar=c(2.5,2.5,0,0))
par(mfrow=c(1,1))
b1=3
vx = seq(-5,5,length=6001)
vy1 = dnorm(vx,-1,1.2)*4
vy2 = dnorm(vx,1.5,.9)*4
plot(vx,vy1,col=colors["A"],xlab="",ylab="",axes=FALSE,type="l",ylim=c(0,10))

M1=c(-1,-1+5)
M2=c(1.5,1.5+5)
S1=matrix(c(1,.5,.5,1)*1.2^2,2,2)
S2=matrix(c(1,-.4,-.4,1)*.9^2,2,2)

A  = sqrtm(S1) %*% S2 %*% (sqrtm(S1))
A  = solve(sqrtm(S1)) %*% sqrtm(A) %*% solve((sqrtm(S1)))
T = function(x) as.vector(M2+A%*%(x-M1))

library(mvtnorm)
vx0 = seq(-5,5,length=251)
data.grid <- expand.grid(x=vx0,y=vx0+5)
dgauss1 = matrix(mvtnorm::dmvnorm(data.grid, mean = M1, sigma = S1),length(vx0),length(vx0))
dgauss2 = matrix(mvtnorm::dmvnorm(data.grid, mean = M2, sigma = S2),length(vx0),length(vx0))

contour(vx0,vx0+5,dgauss1,col=colors["A"],add=TRUE)
contour(vx0,vx0+5,dgauss2,col=colors["B"],add=TRUE)
polygon(c(min(vx),vx,max(vx)),
        c(0,vy1,0),
        col=scales::alpha(colors["A"],.2),
        border=NA)
polygon(c(min(vx),vx,max(vx)),
        c(0,vy2,0),
        col=scales::alpha(colors["B"],.2),
        border=NA)
p1= 0.1586553
a1=qnorm(p1,-1,1.2)
a2=qnorm(p1,1.5,.9)
idx1 = which(vx<=a1)
idx2 = which(vx<=a2)
polygon(c(min(vx),vx[idx1],max(vx[idx1])),
        c(0,vy1[idx1],0),
        col=scales::alpha(colors["A"],.2),
        border=NA)
polygon(c(min(vx),vx[idx2],max(vx[idx2])),
        c(0,vy2[idx2],0),
        col=scales::alpha(colors["B"],.2),
        border=NA)
lines(vx,vy2,col=colors["B"])
segments(a1,0,a1,100,col=colors["A"])
segments(a2,0,a2,100,col=colors["B"])
points(a1,b1,pch=19)
axis(1,at = seq(-2,2)*2,labels=NA)
axis(1,at = a1,
     labels=expression(x[0]),
     col.ticks =NA,
     col.axis = colors["A"], line=.5)
axis(1,at = a2,
     labels=bquote(x[1]~"="~mu[1][x]+frac(sigma[1][x],sigma[0][x])~(x[0]-mu[0][x])),
     col.ticks = NA,
     col.axis = colors["B"], line=.5)
axis(1,at = a1,
     labels=NA,
     col.ticks = colors["A"],line = -.5)
axis(1,at = a2,
     labels=NA,
     col.ticks = colors["B"],line = -.5)

####

y = b1 = 3
vx=vx+5
mu1 = M1[2]+S1[1,2]/S1[1,1]*(a1-M1[1])
sig1=sqrt(S1[2,2]-S1[2,1]^2/S1[2,2])
mu2 = M2[2]+S2[1,2]/S2[1,1]*(a2-M2[1])
sig2=sqrt(S2[2,2]-S2[2,1]^2/S2[2,2])
vz1 = dnorm(vx,mu1,sig1)*3
vz2 = dnorm(vx,mu2,sig2)*3
lines(vz1-5,vx,col=colors["A"])

polygon(c(0,vz1,0)-5,
        c(min(vx),vx,max(vx)),
        col=scales::alpha(colors["A"],.2),
        border=NA)
polygon(c(0,vz2,0)-5,
        c(min(vx),vx,max(vx)),
        col=scales::alpha(colors["B"],.2),
        border=NA)

p1 = pnorm(b1,mu1,sig1)
b2=qnorm(p1,mu2,sig2)
idx1 = which(vx<=b1)
idx2 = which(vx<=b2)
polygon(c(0,vz1[idx1],0)-5,
        c(min(vx),vx[idx1],max(vx[idx1])),
        col=scales::alpha(colors["A"],.2),
        border=NA)
polygon(c(0,vz2[idx2],0)-5,
        c(min(vx),vx[idx2],max(vx[idx2])),
        col=scales::alpha(colors["B"],.2),
        border=NA)
lines(vz2-5,vx,col=colors["B"])
segments(-5,b1,100,b1,col=colors["A"])
segments(-5,b2,100,b2,col=colors["B"])
points(a1,b1,pch=19)
axis(2,at = c(0,1,3,4,5)*2,labels=NA)
axis(2,at = b1,
     labels=expression(y[0]),
     col.ticks =NA,
     col.axis = colors["A"], line=.5)
axis(2,at = b2,
     labels=bquote(y[1]),
     col.ticks = NA,
     col.axis = colors["B"], line=.5)
axis(2,at = b1,
     labels=NA,
     col.ticks = colors["A"],line = -.5)
axis(2,at = b2,
     labels=NA,
     col.ticks = colors["B"],line = -.5)
points(a2,b2,pch=19)
segments(a1,b1,a2,b1,lwd=2)
arrows(a2,b1,a2,b2-.1,length=.1,lwd=2)

XpuisY = matrix(c(a1,b1,a2,b2),2,2)
colnames(XpuisY) = c("start","x_then_y")

M1=c(-1,-1+5)
M2=c(1.5,1.5)
S1=matrix(c(1,.5,.5,1)*1.2^2,2,2)
S2=matrix(c(1,-.4,-.4,1)*.9^2,2,2)

AA  = sqrtm(S1) %*% S2 %*% (sqrtm(S1))
AA  = solve(sqrtm(S1)) %*% sqrtm(AA) %*% solve((sqrtm(S1)))
T = function(x) as.vector(M2+AA%*%(x-M1))

optrasnp=T(c(a1,b1))
XYopt = matrix(c(a1,b1,optrasnp[1],optrasnp[2]+5),2,2)
colnames(XYopt) = c("start","OT")

points(optrasnp[1],optrasnp[2]+5,pch=15,col="#C93312")
```

```{r X2_then_X1, fig.height = 5, fig.width = 5, fig.align = "center", dev.args = list(bg = 'transparent'), echo=FALSE, message=FALSE, warning=FALSE}
par(mar=c(2.5,4,0,0))
par(mfrow=c(1,1))
vx = seq(-5,5,length=6001)
vx=vx+5
M1=c(-1,-1+5)
M2=c(1.5,1.5+5)
S1=matrix(c(1,.5,.5,1)*1.2^2,2,2)
S2=matrix(c(1,-.4,-.4,1)*.9^2,2,2)
b1=3
b2=qnorm(pnorm(b1,5-1,1.2),5+1.5,.9)
mu1 = M1[2]+S1[1,2]/S1[1,1]*(b1-M1[1]-5)
sig1=sqrt(S1[2,2]-S1[2,1]^2/S1[2,2])
mu2 = M2[2]+S2[1,2]/S2[1,1]*(b2-M2[1]-5)
sig2=sqrt(S2[2,2]-S2[2,1]^2/S2[2,2])
vy1 = dnorm(vx,mu1,sig1)*3
vy2 = dnorm(vx,mu2,sig2)*3

vz1 = dnorm(vx-5,-1,1.2)*4
vz2 = dnorm(vx-5,1.5,.9)*4

plot(vx,vy1,col=colors["A"],xlab="",ylab="",axes=FALSE,type="l",ylim=c(0,10))
lines(vz1-5,vx,col=colors["A"])
library(mvtnorm)
vx0 = seq(-5,5,length=251)
data.grid <- expand.grid(x=vx0,y=vx0+5)
dgauss1 = matrix(mvtnorm::dmvnorm(data.grid, mean = M1, sigma = S1),length(vx0),length(vx0))
dgauss2 = matrix(mvtnorm::dmvnorm(data.grid, mean = M2, sigma = S2),length(vx0),length(vx0))

contour(vx0+5,vx0+5,dgauss1,col=colors["A"],add=TRUE)
contour(vx0+5,vx0+5,dgauss2,col=colors["B"],add=TRUE)
polygon(c(min(vx),vx,max(vx)),
        c(0,vy1,0),
        col=scales::alpha(colors["A"],.2),
        border=NA)
polygon(c(min(vx),vx,max(vx)),
        c(0,vy2,0),
        col=scales::alpha(colors["B"],.2),
        border=NA)
a1= -2.2
p1=pnorm(a1+5,mu1,sig1)
a2=qnorm(p1,mu2,sig2)
a1=a1+5
idx1 = which(vx<=a1)
idx2 = which(vx<=a2)
polygon(c(min(vx),vx[idx1],max(vx[idx1])),
        c(0,vy1[idx1],0),
        col=scales::alpha(colors["A"],.2),
        border=NA)
polygon(c(min(vx),vx[idx2],max(vx[idx2])),
        c(0,vy2[idx2],0),
        col=scales::alpha(colors["B"],.2),
        border=NA)
lines(vx,vy2,col=colors["B"])
segments(a1,0,a1,100,col=colors["A"])
segments(a2,0,a2,100,col=colors["B"])
points(a1,b1,pch=19)
axis(1,at = 5+seq(-2,2)*2,labels=NA)
axis(1,at = a1,
     labels=expression(x[0]),
     col.ticks =NA,
     col.axis = colors["A"], line=.5)
axis(1,at = a2,
     labels=bquote(x[1]),
     col.ticks = NA,
     col.axis = colors["B"], line=.5)
axis(1,at = a1,
     labels=NA,
     col.ticks = colors["A"],line = -.5)
axis(1,at = a2,
     labels=NA,
     col.ticks = colors["B"],line = -.5)

####

lines(vz1,vx,col=colors["A"])

polygon(c(0,vz1,0),
        c(min(vx),vx,max(vx)),
        col=scales::alpha(colors["A"],.2),
        border=NA)
polygon(c(0,vz2,0),
        c(min(vx),vx,max(vx)),
        col=scales::alpha(colors["B"],.2),
        border=NA)

p1 = pnorm(b1,5-1,1.2)
b2=qnorm(p1,5+1.5,.9)
idx1 = which(vx<=b1)
idx2 = which(vx<=b2)
polygon(c(0,vz1[idx1],0),
        c(min(vx),vx[idx1],max(vx[idx1])),
        col=scales::alpha(colors["A"],.2),
        border=NA)
polygon(c(0,vz2[idx2],0),
        c(min(vx),vx[idx2],max(vx[idx2])),
        col=scales::alpha(colors["B"],.2),
        border=NA)
lines(vz2,vx,col=colors["B"])
segments(0,b1,100,b1,col=colors["A"])
segments(0,b2,100,b2,col=colors["B"])
points(a1,b1,pch=19)
axis(2,at = c(0,1,3,4,5)*2,labels=NA)
axis(2,at = b1,
     labels=expression(y[0]),
     col.ticks =NA,
     col.axis = colors["A"], line=0)
axis(2,at = b2,
     labels=bquote(y[1]~"="~mu[1][y]+frac(sigma[1][y],sigma[0][y])~(y[0]-mu[0][y])),
     col.ticks = NA,
     col.axis = colors["B"], line=.5)
axis(2,at = b1,
     labels=NA,
     col.ticks = colors["A"],line = -.5)
axis(2,at = b2,
     labels=NA,
     col.ticks = colors["B"],line = -.5)
points(a2,b2,pch=19)
segments(a1,b1,a1,b2,lwd=2)
arrows(a1,b2,a2-.1,b2,length=.1,lwd=2)

YpuisX = matrix(c(a1,b1,a2,b2),2,2)
colnames(YpuisX) = c("start","y_then_x")

M1=c(-1,-1)
M2=c(1.5,1.5)
S1=matrix(c(1,.5,.5,1)*1.2^2,2,2)
S2=matrix(c(1,-.4,-.4,1)*.9^2,2,2)

AA  = sqrtm(S1) %*% S2 %*% (sqrtm(S1))
AA  = solve(sqrtm(S1)) %*% sqrtm(AA) %*% solve((sqrtm(S1)))
T = function(x) as.vector(M2+AA%*%(x-M1))
optrasnp=T(c(a1-5,b1-5))
points(optrasnp[1]+5,optrasnp[2]+5,pch=15,col="#C93312")
```

```{r aaai-ellipse-1, fig.height = 5, fig.width = 5, fig.align = "center", dev.args = list(bg = 'transparent'), echo=FALSE, message=FALSE, warning=FALSE}

angle = function(theta,
                 A = c(-2.2,-2)){
  
  R = matrix(c(cos(theta),sin(theta),
               -sin(theta),cos(theta)),2,2)
M1=c(-1,-1)
M2=c(1.5,1.5)
S1=matrix(c(1,.5,.5,1)*1.2^2,2,2)
S2=matrix(c(1,-.4,-.4,1)*.9^2,2,2)


M1 = as.vector(R%*%M1)
M2 = as.vector(R%*%M2)
S1 = t(R)%*%S1%*%R
S2 = t(R)%*%S2%*%R
A =  as.vector(R %*%A)

a1 = A[1]
b1 = A[2]
a2 = qnorm(pnorm(a1,M1[1],sqrt(S1[1,1])),
                M2[1],sqrt(S2[1,1]))
mu1 = M1[2]+S1[1,2]/S1[1,1]*(a1-M1[1])
sig1=sqrt(S1[2,2]-S1[2,1]^2/S1[2,2])
mu2 = M2[2]+S2[1,2]/S2[1,1]*(a2-M2[1])
sig2=sqrt(S2[2,2]-S2[2,1]^2/S2[2,2])
p1 = pnorm(b1,mu1,sig1)
b2=qnorm(p1,mu2,sig2)
B = c(a2,b2)
return(c(
as.vector(t(R)%*%A),
as.vector(t(R)%*%B)))
}

M1=c(-1,-1)
M2=c(1.5,1.5)
S1=matrix(c(1,.5,.5,1)*1.2^2,2,2)
S2=matrix(c(1,-.4,-.4,1)*.9^2,2,2)

A = c(-2.2,-2)

par(mfrow=c(1,1),mar=c(.5,.5,0,0))

library(mvtnorm)
vx0 = seq(-5,5,length=251)
data.grid <- expand.grid(x=vx0,y=vx0)
dgauss1 = matrix(mvtnorm::dmvnorm(data.grid, mean = M1, sigma = S1),length(vx0),length(vx0))
dgauss2 = matrix(mvtnorm::dmvnorm(data.grid, mean = M2, sigma = S2),length(vx0),length(vx0))

contour(vx0,vx0,dgauss1,col=colors["A"],xlim=c(-5,5),ylim=c(-5,5),axes=FALSE)
contour(vx0,vx0,dgauss2,col=colors["B"],add=TRUE)

segments(A[1],-5,A[1],100,col=colors["A"])
segments(-5,A[2],100,A[2],col=colors["A"])
points(A[1],A[2],pch=19)
axis(1,at = c(0,1,2,3,4,5)*2-5,labels=NA)
axis(2,at = c(0,1,2,3,4,5)*2-5,labels=NA)

MANGLE = Vectorize(angle)(seq(0,2*pi,length=100))
lines(MANGLE[3,],MANGLE[4,])
m=angle(0,c(-2.2,-2)); points(m[3],m[4],pch=19)
m=angle(pi/2,c(-2.2,-2)); points(m[3],m[4],pch=19)

T = function(x) as.vector(M2+AA%*%(x-M1))
optrasnp=T(c(A[1],A[2]))
points(optrasnp[1],optrasnp[2],pch=15,col="#C93312")

A = c(-2.2,.5)

par(mfrow=c(1,1),mar=c(.5,.5,0,0))

library(mvtnorm)
vx0 = seq(-5,5,length=251)
data.grid <- expand.grid(x=vx0,y=vx0)
dgauss1 = matrix(mvtnorm::dmvnorm(data.grid, mean = M1, sigma = S1),length(vx0),length(vx0))
dgauss2 = matrix(mvtnorm::dmvnorm(data.grid, mean = M2, sigma = S2),length(vx0),length(vx0))

contour(vx0,vx0,dgauss1,col=colors["A"],xlim=c(-5,5),ylim=c(-5,5),axes=FALSE)
contour(vx0,vx0,dgauss2,col=colors["B"],add=TRUE)

segments(A[1],-5,A[1],100,col=colors["A"])
segments(-5,A[2],100,A[2],col=colors["A"])
points(A[1],A[2],pch=19)
axis(1,at = c(0,1,2,3,4,5)*2-5,labels=NA)
axis(2,at = c(0,1,2,3,4,5)*2-5,labels=NA)

MANGLE = Vectorize(function(x) angle(x,c(-2.2,.5)))(seq(0,2*pi,length=100))
lines(MANGLE[3,],MANGLE[4,])
m=angle(0,c(-2.2,.5)); points(m[3],m[4],pch=19)
m=angle(pi/2,c(-2.2,.5)); points(m[3],m[4],pch=19)

AA  = sqrtm(S1) %*% S2 %*% (sqrtm(S1))
AA  = solve(sqrtm(S1)) %*% sqrtm(AA) %*% solve((sqrtm(S1)))
T = function(x) as.vector(M2+AA%*%(x-M1))
optrasnp=T(c(A[1],A[2]))
points(optrasnp[1],optrasnp[2],pch=15,col="#C93312")

par(mfrow=c(1,1),mar=c(.5,.5,0,0))
MANGLE = Vectorize(function(x) angle(x,c(-2.2,.5)))(seq(0,2*pi,length=100))
plot(MANGLE[3,],MANGLE[4,],type="b",cex=.6,xlab="",ylab="")

MANGLE = Vectorize(function(x) angle(x,c(-2.2,-1)))(seq(0,2*pi,length=100))
plot(MANGLE[3,],MANGLE[4,],type="b",cex=.6,xlab="",ylab="")

MANGLE = Vectorize(function(x) angle(x,c(0,0)))(seq(0,2*pi,length=100))
plot(MANGLE[3,],MANGLE[4,],type="b",cex=.6,xlab="",ylab="")

MANGLE = Vectorize(function(x) angle(x,c(1,4)))(seq(0,2*pi,length=100))
plot(MANGLE[3,],MANGLE[4,],type="b",cex=.6,xlab="",ylab="")
```
